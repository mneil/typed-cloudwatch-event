/**
 * STOP. This file is autogenerated. DO NOT EDIT by hand
 */
export interface CreateGatewayRoute {
  readonly clientToken: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: GatewayRouteSpec;
  readonly tags: [];
  readonly virtualGatewayName: string;
}
export interface CreateMesh {
  readonly clientToken: string;
  readonly meshName: string;
  readonly spec: MeshSpec;
  readonly tags: [];
}
export interface CreateRoute {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly tags: [];
  readonly virtualRouterName: string;
}
export interface CreateVirtualGateway {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualGatewaySpec;
  readonly tags: [];
  readonly virtualGatewayName: string;
}
export interface CreateVirtualNode {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualNodeSpec;
  readonly tags: [];
  readonly virtualNodeName: string;
}
export interface CreateVirtualRouter {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualRouterSpec;
  readonly tags: [];
  readonly virtualRouterName: string;
}
export interface CreateVirtualService {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualServiceSpec;
  readonly tags: [];
  readonly virtualServiceName: string;
}
export interface DeleteGatewayRoute {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}
export interface DeleteMesh {
  readonly meshName: string;
}
export interface DeleteRoute {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}
export interface DeleteVirtualGateway {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}
export interface DeleteVirtualNode {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualNodeName: string;
}
export interface DeleteVirtualRouter {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualRouterName: string;
}
export interface DeleteVirtualService {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualServiceName: string;
}
export interface DescribeGatewayRoute {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}
export interface DescribeMesh {
  readonly meshName: string;
  readonly meshOwner: string;
}
export interface DescribeRoute {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}
export interface DescribeVirtualGateway {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}
export interface DescribeVirtualNode {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualNodeName: string;
}
export interface DescribeVirtualRouter {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualRouterName: string;
}
export interface DescribeVirtualService {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualServiceName: string;
}
export interface ListGatewayRoutes {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
  readonly virtualGatewayName: string;
}
export interface ListMeshes {
  readonly limit: number;
  readonly nextToken: string;
}
export interface ListRoutes {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
  readonly virtualRouterName: string;
}
export interface ListTagsForResource {
  readonly limit: number;
  readonly nextToken: string;
  readonly resourceArn: string;
}
export interface ListVirtualGateways {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}
export interface ListVirtualNodes {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}
export interface ListVirtualRouters {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}
export interface ListVirtualServices {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}
export interface TagResource {
  readonly resourceArn: string;
  readonly tags: [];
}
export interface UntagResource {
  readonly resourceArn: string;
  readonly tagKeys: [];
}
export interface UpdateGatewayRoute {
  readonly clientToken: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: GatewayRouteSpec;
  readonly virtualGatewayName: string;
}
export interface UpdateMesh {
  readonly clientToken: string;
  readonly meshName: string;
  readonly spec: MeshSpec;
}
export interface UpdateRoute {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly virtualRouterName: string;
}
export interface UpdateVirtualGateway {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualGatewaySpec;
  readonly virtualGatewayName: string;
}
export interface UpdateVirtualNode {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualNodeSpec;
  readonly virtualNodeName: string;
}
export interface UpdateVirtualRouter {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualRouterSpec;
  readonly virtualRouterName: string;
}
export interface UpdateVirtualService {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualServiceSpec;
  readonly virtualServiceName: string;
}



interface AccessLog {
  readonly file: FileAccessLog;
}

interface AwsCloudMapInstanceAttribute {
  readonly key: string;
  readonly value: string;
}

interface AwsCloudMapServiceDiscovery {
  readonly attributes: [];
  readonly namespaceName: string;
  readonly serviceName: string;
}

interface Backend {
  readonly virtualService: VirtualServiceBackend;
}

interface BackendDefaults {
  readonly clientPolicy: ClientPolicy;
}

interface BadRequestException {
  readonly message: string;
}

interface ClientPolicy {
  readonly tls: ClientPolicyTls;
}

interface ClientPolicyTls {
  readonly certificate: ClientTlsCertificate;
  readonly enforce: boolean;
  readonly ports: [];
  readonly validation: TlsValidationContext;
}

interface ClientTlsCertificate {
  readonly file: ListenerTlsFileCertificate;
  readonly sds: ListenerTlsSdsCertificate;
}

interface ConflictException {
  readonly message: string;
}

interface CreateGatewayRouteInput {
  readonly clientToken: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: GatewayRouteSpec;
  readonly tags: [];
  readonly virtualGatewayName: string;
}

interface CreateGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

interface CreateMeshInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly spec: MeshSpec;
  readonly tags: [];
}

interface CreateMeshOutput {
  readonly mesh: MeshData;
}

interface CreateRouteInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly tags: [];
  readonly virtualRouterName: string;
}

interface CreateRouteOutput {
  readonly route: RouteData;
}

interface CreateVirtualGatewayInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualGatewaySpec;
  readonly tags: [];
  readonly virtualGatewayName: string;
}

interface CreateVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

interface CreateVirtualNodeInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualNodeSpec;
  readonly tags: [];
  readonly virtualNodeName: string;
}

interface CreateVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

interface CreateVirtualRouterInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualRouterSpec;
  readonly tags: [];
  readonly virtualRouterName: string;
}

interface CreateVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

interface CreateVirtualServiceInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualServiceSpec;
  readonly tags: [];
  readonly virtualServiceName: string;
}

interface CreateVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

interface DeleteGatewayRouteInput {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}

interface DeleteGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

interface DeleteMeshInput {
  readonly meshName: string;
}

interface DeleteMeshOutput {
  readonly mesh: MeshData;
}

interface DeleteRouteInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

interface DeleteRouteOutput {
  readonly route: RouteData;
}

interface DeleteVirtualGatewayInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}

interface DeleteVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

interface DeleteVirtualNodeInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualNodeName: string;
}

interface DeleteVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

interface DeleteVirtualRouterInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualRouterName: string;
}

interface DeleteVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

interface DeleteVirtualServiceInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualServiceName: string;
}

interface DeleteVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

interface DescribeGatewayRouteInput {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}

interface DescribeGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

interface DescribeMeshInput {
  readonly meshName: string;
  readonly meshOwner: string;
}

interface DescribeMeshOutput {
  readonly mesh: MeshData;
}

interface DescribeRouteInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

interface DescribeRouteOutput {
  readonly route: RouteData;
}

interface DescribeVirtualGatewayInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualGatewayName: string;
}

interface DescribeVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

interface DescribeVirtualNodeInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualNodeName: string;
}

interface DescribeVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

interface DescribeVirtualRouterInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualRouterName: string;
}

interface DescribeVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

interface DescribeVirtualServiceInput {
  readonly meshName: string;
  readonly meshOwner: string;
  readonly virtualServiceName: string;
}

interface DescribeVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

interface DnsServiceDiscovery {
  readonly hostname: string;
  readonly responseType: string;
}

interface Duration {
  readonly unit: string;
  readonly value: number;
}

interface EgressFilter {
  readonly type: string;
}

interface FileAccessLog {
  readonly path: string;
}

interface ForbiddenException {
  readonly message: string;
}

interface GatewayRouteData {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: GatewayRouteSpec;
  readonly status: GatewayRouteStatus;
  readonly virtualGatewayName: string;
}

interface GatewayRouteHostnameMatch {
  readonly exact: string;
  readonly suffix: string;
}

interface GatewayRouteHostnameRewrite {
  readonly defaultTargetHostname: string;
}

interface GatewayRouteRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly gatewayRouteName: string;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualGatewayName: string;
}

interface GatewayRouteSpec {
  readonly grpcRoute: GrpcGatewayRoute;
  readonly http2Route: HttpGatewayRoute;
  readonly httpRoute: HttpGatewayRoute;
  readonly priority: number;
}

interface GatewayRouteStatus {
  readonly status: string;
}

interface GatewayRouteTarget {
  readonly virtualService: GatewayRouteVirtualService;
}

interface GatewayRouteVirtualService {
  readonly virtualServiceName: string;
}

interface GrpcGatewayRoute {
  readonly action: GrpcGatewayRouteAction;
  readonly match: GrpcGatewayRouteMatch;
}

interface GrpcGatewayRouteAction {
  readonly rewrite: GrpcGatewayRouteRewrite;
  readonly target: GatewayRouteTarget;
}

interface GrpcGatewayRouteMatch {
  readonly hostname: GatewayRouteHostnameMatch;
  readonly metadata: [];
  readonly serviceName: string;
}

interface GrpcGatewayRouteMetadata {
  readonly invert: boolean;
  readonly match: GrpcMetadataMatchMethod;
  readonly name: string;
}

interface GrpcGatewayRouteRewrite {
  readonly hostname: GatewayRouteHostnameRewrite;
}

interface GrpcMetadataMatchMethod {
  readonly exact: string;
  readonly prefix: string;
  readonly range: MatchRange;
  readonly regex: string;
  readonly suffix: string;
}

interface GrpcRetryPolicy {
  readonly grpcRetryEvents: [];
  readonly httpRetryEvents: [];
  readonly maxRetries: number;
  readonly perRetryTimeout: Duration;
  readonly tcpRetryEvents: [];
}

interface GrpcRoute {
  readonly action: GrpcRouteAction;
  readonly match: GrpcRouteMatch;
  readonly retryPolicy: GrpcRetryPolicy;
  readonly timeout: GrpcTimeout;
}

interface GrpcRouteAction {
  readonly weightedTargets: [];
}

interface GrpcRouteMatch {
  readonly metadata: [];
  readonly methodName: string;
  readonly serviceName: string;
}

interface GrpcRouteMetadata {
  readonly invert: boolean;
  readonly match: GrpcRouteMetadataMatchMethod;
  readonly name: string;
}

interface GrpcRouteMetadataMatchMethod {
  readonly exact: string;
  readonly prefix: string;
  readonly range: MatchRange;
  readonly regex: string;
  readonly suffix: string;
}

interface GrpcTimeout {
  readonly idle: Duration;
  readonly perRequest: Duration;
}

interface HeaderMatchMethod {
  readonly exact: string;
  readonly prefix: string;
  readonly range: MatchRange;
  readonly regex: string;
  readonly suffix: string;
}

interface HealthCheckPolicy {
  readonly healthyThreshold: number;
  readonly intervalMillis: number;
  readonly path: string;
  readonly port: number;
  readonly protocol: string;
  readonly timeoutMillis: number;
  readonly unhealthyThreshold: number;
}

interface HttpGatewayRoute {
  readonly action: HttpGatewayRouteAction;
  readonly match: HttpGatewayRouteMatch;
}

interface HttpGatewayRouteAction {
  readonly rewrite: HttpGatewayRouteRewrite;
  readonly target: GatewayRouteTarget;
}

interface HttpGatewayRouteHeader {
  readonly invert: boolean;
  readonly match: HeaderMatchMethod;
  readonly name: string;
}

interface HttpGatewayRouteMatch {
  readonly headers: [];
  readonly hostname: GatewayRouteHostnameMatch;
  readonly method: string;
  readonly path: HttpPathMatch;
  readonly prefix: string;
  readonly queryParameters: [];
}

interface HttpGatewayRoutePathRewrite {
  readonly exact: string;
}

interface HttpGatewayRoutePrefixRewrite {
  readonly defaultPrefix: string;
  readonly value: string;
}

interface HttpGatewayRouteRewrite {
  readonly hostname: GatewayRouteHostnameRewrite;
  readonly path: HttpGatewayRoutePathRewrite;
  readonly prefix: HttpGatewayRoutePrefixRewrite;
}

interface HttpPathMatch {
  readonly exact: string;
  readonly regex: string;
}

interface HttpQueryParameter {
  readonly match: QueryParameterMatch;
  readonly name: string;
}

interface HttpRetryPolicy {
  readonly httpRetryEvents: [];
  readonly maxRetries: number;
  readonly perRetryTimeout: Duration;
  readonly tcpRetryEvents: [];
}

interface HttpRoute {
  readonly action: HttpRouteAction;
  readonly match: HttpRouteMatch;
  readonly retryPolicy: HttpRetryPolicy;
  readonly timeout: HttpTimeout;
}

interface HttpRouteAction {
  readonly weightedTargets: [];
}

interface HttpRouteHeader {
  readonly invert: boolean;
  readonly match: HeaderMatchMethod;
  readonly name: string;
}

interface HttpRouteMatch {
  readonly headers: [];
  readonly method: string;
  readonly path: HttpPathMatch;
  readonly prefix: string;
  readonly queryParameters: [];
  readonly scheme: string;
}

interface HttpTimeout {
  readonly idle: Duration;
  readonly perRequest: Duration;
}

interface InternalServerErrorException {
  readonly message: string;
}

interface LimitExceededException {
  readonly message: string;
}

interface ListGatewayRoutesInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
  readonly virtualGatewayName: string;
}

interface ListGatewayRoutesOutput {
  readonly gatewayRoutes: [];
  readonly nextToken: string;
}

interface ListMeshesInput {
  readonly limit: number;
  readonly nextToken: string;
}

interface ListMeshesOutput {
  readonly meshes: [];
  readonly nextToken: string;
}

interface ListRoutesInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
  readonly virtualRouterName: string;
}

interface ListRoutesOutput {
  readonly nextToken: string;
  readonly routes: [];
}

interface ListTagsForResourceInput {
  readonly limit: number;
  readonly nextToken: string;
  readonly resourceArn: string;
}

interface ListTagsForResourceOutput {
  readonly nextToken: string;
  readonly tags: [];
}

interface ListVirtualGatewaysInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}

interface ListVirtualGatewaysOutput {
  readonly nextToken: string;
  readonly virtualGateways: [];
}

interface ListVirtualNodesInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}

interface ListVirtualNodesOutput {
  readonly nextToken: string;
  readonly virtualNodes: [];
}

interface ListVirtualRoutersInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}

interface ListVirtualRoutersOutput {
  readonly nextToken: string;
  readonly virtualRouters: [];
}

interface ListVirtualServicesInput {
  readonly limit: number;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly nextToken: string;
}

interface ListVirtualServicesOutput {
  readonly nextToken: string;
  readonly virtualServices: [];
}

interface Listener {
  readonly connectionPool: VirtualNodeConnectionPool;
  readonly healthCheck: HealthCheckPolicy;
  readonly outlierDetection: OutlierDetection;
  readonly portMapping: PortMapping;
  readonly timeout: ListenerTimeout;
  readonly tls: ListenerTls;
}

interface ListenerTimeout {
  readonly grpc: GrpcTimeout;
  readonly http: HttpTimeout;
  readonly http2: HttpTimeout;
  readonly tcp: TcpTimeout;
}

interface ListenerTls {
  readonly certificate: ListenerTlsCertificate;
  readonly mode: string;
  readonly validation: ListenerTlsValidationContext;
}

interface ListenerTlsAcmCertificate {
  readonly certificateArn: string;
}

interface ListenerTlsCertificate {
  readonly acm: ListenerTlsAcmCertificate;
  readonly file: ListenerTlsFileCertificate;
  readonly sds: ListenerTlsSdsCertificate;
}

interface ListenerTlsFileCertificate {
  readonly certificateChain: string;
  readonly privateKey: string;
}

interface ListenerTlsSdsCertificate {
  readonly secretName: string;
}

interface ListenerTlsValidationContext {
  readonly subjectAlternativeNames: SubjectAlternativeNames;
  readonly trust: ListenerTlsValidationContextTrust;
}

interface ListenerTlsValidationContextTrust {
  readonly file: TlsValidationContextFileTrust;
  readonly sds: TlsValidationContextSdsTrust;
}

interface Logging {
  readonly accessLog: AccessLog;
}

interface MatchRange {
  readonly end: number;
  readonly start: number;
}

interface MeshData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: MeshSpec;
  readonly status: MeshStatus;
}

interface MeshRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
}

interface MeshSpec {
  readonly egressFilter: EgressFilter;
}

interface MeshStatus {
  readonly status: string;
}

interface NotFoundException {
  readonly message: string;
}

interface OutlierDetection {
  readonly baseEjectionDuration: Duration;
  readonly interval: Duration;
  readonly maxEjectionPercent: number;
  readonly maxServerErrors: number;
}

interface PortMapping {
  readonly port: number;
  readonly protocol: string;
}

interface QueryParameterMatch {
  readonly exact: string;
}

interface ResourceInUseException {
  readonly message: string;
}

interface ResourceMetadata {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly uid: string;
  readonly version: number;
}

interface RouteData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly status: RouteStatus;
  readonly virtualRouterName: string;
}

interface RouteRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly routeName: string;
  readonly version: number;
  readonly virtualRouterName: string;
}

interface RouteSpec {
  readonly grpcRoute: GrpcRoute;
  readonly http2Route: HttpRoute;
  readonly httpRoute: HttpRoute;
  readonly priority: number;
  readonly tcpRoute: TcpRoute;
}

interface RouteStatus {
  readonly status: string;
}

interface ServiceDiscovery {
  readonly awsCloudMap: AwsCloudMapServiceDiscovery;
  readonly dns: DnsServiceDiscovery;
}

interface ServiceUnavailableException {
  readonly message: string;
}

interface SubjectAlternativeNameMatchers {
  readonly exact: [];
}

interface SubjectAlternativeNames {
  readonly match: SubjectAlternativeNameMatchers;
}

interface TagRef {
  readonly key: string;
  readonly value: string;
}

interface TagResourceInput {
  readonly resourceArn: string;
  readonly tags: [];
}

interface TagResourceOutput {
}

interface TcpRoute {
  readonly action: TcpRouteAction;
  readonly timeout: TcpTimeout;
}

interface TcpRouteAction {
  readonly weightedTargets: [];
}

interface TcpTimeout {
  readonly idle: Duration;
}

interface TlsValidationContext {
  readonly subjectAlternativeNames: SubjectAlternativeNames;
  readonly trust: TlsValidationContextTrust;
}

interface TlsValidationContextAcmTrust {
  readonly certificateAuthorityArns: [];
}

interface TlsValidationContextFileTrust {
  readonly certificateChain: string;
}

interface TlsValidationContextSdsTrust {
  readonly secretName: string;
}

interface TlsValidationContextTrust {
  readonly acm: TlsValidationContextAcmTrust;
  readonly file: TlsValidationContextFileTrust;
  readonly sds: TlsValidationContextSdsTrust;
}

interface TooManyRequestsException {
  readonly message: string;
}

interface TooManyTagsException {
  readonly message: string;
}

interface UntagResourceInput {
  readonly resourceArn: string;
  readonly tagKeys: [];
}

interface UntagResourceOutput {
}

interface UpdateGatewayRouteInput {
  readonly clientToken: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: GatewayRouteSpec;
  readonly virtualGatewayName: string;
}

interface UpdateGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

interface UpdateMeshInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly spec: MeshSpec;
}

interface UpdateMeshOutput {
  readonly mesh: MeshData;
}

interface UpdateRouteInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly virtualRouterName: string;
}

interface UpdateRouteOutput {
  readonly route: RouteData;
}

interface UpdateVirtualGatewayInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualGatewaySpec;
  readonly virtualGatewayName: string;
}

interface UpdateVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

interface UpdateVirtualNodeInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualNodeSpec;
  readonly virtualNodeName: string;
}

interface UpdateVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

interface UpdateVirtualRouterInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualRouterSpec;
  readonly virtualRouterName: string;
}

interface UpdateVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

interface UpdateVirtualServiceInput {
  readonly clientToken: string;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly spec: VirtualServiceSpec;
  readonly virtualServiceName: string;
}

interface UpdateVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

interface VirtualGatewayAccessLog {
  readonly file: VirtualGatewayFileAccessLog;
}

interface VirtualGatewayBackendDefaults {
  readonly clientPolicy: VirtualGatewayClientPolicy;
}

interface VirtualGatewayClientPolicy {
  readonly tls: VirtualGatewayClientPolicyTls;
}

interface VirtualGatewayClientPolicyTls {
  readonly certificate: VirtualGatewayClientTlsCertificate;
  readonly enforce: boolean;
  readonly ports: [];
  readonly validation: VirtualGatewayTlsValidationContext;
}

interface VirtualGatewayClientTlsCertificate {
  readonly file: VirtualGatewayListenerTlsFileCertificate;
  readonly sds: VirtualGatewayListenerTlsSdsCertificate;
}

interface VirtualGatewayConnectionPool {
  readonly grpc: VirtualGatewayGrpcConnectionPool;
  readonly http: VirtualGatewayHttpConnectionPool;
  readonly http2: VirtualGatewayHttp2ConnectionPool;
}

interface VirtualGatewayData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualGatewaySpec;
  readonly status: VirtualGatewayStatus;
  readonly virtualGatewayName: string;
}

interface VirtualGatewayFileAccessLog {
  readonly path: string;
}

interface VirtualGatewayGrpcConnectionPool {
  readonly maxRequests: number;
}

interface VirtualGatewayHealthCheckPolicy {
  readonly healthyThreshold: number;
  readonly intervalMillis: number;
  readonly path: string;
  readonly port: number;
  readonly protocol: string;
  readonly timeoutMillis: number;
  readonly unhealthyThreshold: number;
}

interface VirtualGatewayHttp2ConnectionPool {
  readonly maxRequests: number;
}

interface VirtualGatewayHttpConnectionPool {
  readonly maxConnections: number;
  readonly maxPendingRequests: number;
}

interface VirtualGatewayListener {
  readonly connectionPool: VirtualGatewayConnectionPool;
  readonly healthCheck: VirtualGatewayHealthCheckPolicy;
  readonly portMapping: VirtualGatewayPortMapping;
  readonly tls: VirtualGatewayListenerTls;
}

interface VirtualGatewayListenerTls {
  readonly certificate: VirtualGatewayListenerTlsCertificate;
  readonly mode: string;
  readonly validation: VirtualGatewayListenerTlsValidationContext;
}

interface VirtualGatewayListenerTlsAcmCertificate {
  readonly certificateArn: string;
}

interface VirtualGatewayListenerTlsCertificate {
  readonly acm: VirtualGatewayListenerTlsAcmCertificate;
  readonly file: VirtualGatewayListenerTlsFileCertificate;
  readonly sds: VirtualGatewayListenerTlsSdsCertificate;
}

interface VirtualGatewayListenerTlsFileCertificate {
  readonly certificateChain: string;
  readonly privateKey: string;
}

interface VirtualGatewayListenerTlsSdsCertificate {
  readonly secretName: string;
}

interface VirtualGatewayListenerTlsValidationContext {
  readonly subjectAlternativeNames: SubjectAlternativeNames;
  readonly trust: VirtualGatewayListenerTlsValidationContextTrust;
}

interface VirtualGatewayListenerTlsValidationContextTrust {
  readonly file: VirtualGatewayTlsValidationContextFileTrust;
  readonly sds: VirtualGatewayTlsValidationContextSdsTrust;
}

interface VirtualGatewayLogging {
  readonly accessLog: VirtualGatewayAccessLog;
}

interface VirtualGatewayPortMapping {
  readonly port: number;
  readonly protocol: string;
}

interface VirtualGatewayRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualGatewayName: string;
}

interface VirtualGatewaySpec {
  readonly backendDefaults: VirtualGatewayBackendDefaults;
  readonly listeners: [];
  readonly logging: VirtualGatewayLogging;
}

interface VirtualGatewayStatus {
  readonly status: string;
}

interface VirtualGatewayTlsValidationContext {
  readonly subjectAlternativeNames: SubjectAlternativeNames;
  readonly trust: VirtualGatewayTlsValidationContextTrust;
}

interface VirtualGatewayTlsValidationContextAcmTrust {
  readonly certificateAuthorityArns: [];
}

interface VirtualGatewayTlsValidationContextFileTrust {
  readonly certificateChain: string;
}

interface VirtualGatewayTlsValidationContextSdsTrust {
  readonly secretName: string;
}

interface VirtualGatewayTlsValidationContextTrust {
  readonly acm: VirtualGatewayTlsValidationContextAcmTrust;
  readonly file: VirtualGatewayTlsValidationContextFileTrust;
  readonly sds: VirtualGatewayTlsValidationContextSdsTrust;
}

interface VirtualNodeConnectionPool {
  readonly grpc: VirtualNodeGrpcConnectionPool;
  readonly http: VirtualNodeHttpConnectionPool;
  readonly http2: VirtualNodeHttp2ConnectionPool;
  readonly tcp: VirtualNodeTcpConnectionPool;
}

interface VirtualNodeData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualNodeSpec;
  readonly status: VirtualNodeStatus;
  readonly virtualNodeName: string;
}

interface VirtualNodeGrpcConnectionPool {
  readonly maxRequests: number;
}

interface VirtualNodeHttp2ConnectionPool {
  readonly maxRequests: number;
}

interface VirtualNodeHttpConnectionPool {
  readonly maxConnections: number;
  readonly maxPendingRequests: number;
}

interface VirtualNodeRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualNodeName: string;
}

interface VirtualNodeServiceProvider {
  readonly virtualNodeName: string;
}

interface VirtualNodeSpec {
  readonly backendDefaults: BackendDefaults;
  readonly backends: [];
  readonly listeners: [];
  readonly logging: Logging;
  readonly serviceDiscovery: ServiceDiscovery;
}

interface VirtualNodeStatus {
  readonly status: string;
}

interface VirtualNodeTcpConnectionPool {
  readonly maxConnections: number;
}

interface VirtualRouterData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualRouterSpec;
  readonly status: VirtualRouterStatus;
  readonly virtualRouterName: string;
}

interface VirtualRouterListener {
  readonly portMapping: PortMapping;
}

interface VirtualRouterRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualRouterName: string;
}

interface VirtualRouterServiceProvider {
  readonly virtualRouterName: string;
}

interface VirtualRouterSpec {
  readonly listeners: [];
}

interface VirtualRouterStatus {
  readonly status: string;
}

interface VirtualServiceBackend {
  readonly clientPolicy: ClientPolicy;
  readonly virtualServiceName: string;
}

interface VirtualServiceData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualServiceSpec;
  readonly status: VirtualServiceStatus;
  readonly virtualServiceName: string;
}

interface VirtualServiceProvider {
  readonly virtualNode: VirtualNodeServiceProvider;
  readonly virtualRouter: VirtualRouterServiceProvider;
}

interface VirtualServiceRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualServiceName: string;
}

interface VirtualServiceSpec {
  readonly provider: VirtualServiceProvider;
}

interface VirtualServiceStatus {
  readonly status: string;
}

interface WeightedTarget {
  readonly virtualNode: string;
  readonly weight: number;
}

