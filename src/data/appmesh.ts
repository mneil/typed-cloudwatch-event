/**
 * STOP. This file is autogenerated. DO NOT EDIT by hand
 */
export interface CreateGatewayRoute {
  readonly clientToken?: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: GatewayRouteSpec;
  readonly tags?: [];
  readonly virtualGatewayName: string;
}

export interface CreateMesh {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly spec?: MeshSpec;
  readonly tags?: [];
}

export interface CreateRoute {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly tags?: [];
  readonly virtualRouterName: string;
}

export interface CreateVirtualGateway {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualGatewaySpec;
  readonly tags?: [];
  readonly virtualGatewayName: string;
}

export interface CreateVirtualNode {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualNodeSpec;
  readonly tags?: [];
  readonly virtualNodeName: string;
}

export interface CreateVirtualRouter {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualRouterSpec;
  readonly tags?: [];
  readonly virtualRouterName: string;
}

export interface CreateVirtualService {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualServiceSpec;
  readonly tags?: [];
  readonly virtualServiceName: string;
}

export interface DeleteGatewayRoute {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DeleteMesh {
  readonly meshName: string;
}

export interface DeleteRoute {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

export interface DeleteVirtualGateway {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DeleteVirtualNode {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualNodeName: string;
}

export interface DeleteVirtualRouter {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualRouterName: string;
}

export interface DeleteVirtualService {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualServiceName: string;
}

export interface DescribeGatewayRoute {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DescribeMesh {
  readonly meshName: string;
  readonly meshOwner?: string;
}

export interface DescribeRoute {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

export interface DescribeVirtualGateway {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DescribeVirtualNode {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualNodeName: string;
}

export interface DescribeVirtualRouter {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualRouterName: string;
}

export interface DescribeVirtualService {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualServiceName: string;
}

export interface ListGatewayRoutes {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
  readonly virtualGatewayName: string;
}

export interface ListMeshes {
  readonly limit?: number;
  readonly nextToken?: string;
}

export interface ListRoutes {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
  readonly virtualRouterName: string;
}

export interface ListTagsForResource {
  readonly limit?: number;
  readonly nextToken?: string;
  readonly resourceArn: string;
}

export interface ListVirtualGateways {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualNodes {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualRouters {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualServices {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface TagResource {
  readonly resourceArn: string;
  readonly tags: [];
}

export interface UntagResource {
  readonly resourceArn: string;
  readonly tagKeys: [];
}

export interface UpdateGatewayRoute {
  readonly clientToken?: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: GatewayRouteSpec;
  readonly virtualGatewayName: string;
}

export interface UpdateMesh {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly spec?: MeshSpec;
}

export interface UpdateRoute {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly virtualRouterName: string;
}

export interface UpdateVirtualGateway {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualGatewaySpec;
  readonly virtualGatewayName: string;
}

export interface UpdateVirtualNode {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualNodeSpec;
  readonly virtualNodeName: string;
}

export interface UpdateVirtualRouter {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualRouterSpec;
  readonly virtualRouterName: string;
}

export interface UpdateVirtualService {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualServiceSpec;
  readonly virtualServiceName: string;
}

export interface AccessLog {
  readonly file?: FileAccessLog;
}

export interface AwsCloudMapInstanceAttribute {
  readonly key: string;
  readonly value: string;
}

export interface AwsCloudMapServiceDiscovery {
  readonly attributes?: [];
  readonly namespaceName: string;
  readonly serviceName: string;
}

export interface Backend {
  readonly virtualService?: VirtualServiceBackend;
}

export interface BackendDefaults {
  readonly clientPolicy?: ClientPolicy;
}

export interface BadRequestException {
  readonly message?: string;
}

export interface ClientPolicy {
  readonly tls?: ClientPolicyTls;
}

export interface ClientPolicyTls {
  readonly certificate?: ClientTlsCertificate;
  readonly enforce?: boolean;
  readonly ports?: [];
  readonly validation: TlsValidationContext;
}

export interface ClientTlsCertificate {
  readonly file?: ListenerTlsFileCertificate;
  readonly sds?: ListenerTlsSdsCertificate;
}

export interface ConflictException {
  readonly message?: string;
}

export interface CreateGatewayRouteInput {
  readonly clientToken?: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: GatewayRouteSpec;
  readonly tags?: [];
  readonly virtualGatewayName: string;
}

export interface CreateGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

export interface CreateMeshInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly spec?: MeshSpec;
  readonly tags?: [];
}

export interface CreateMeshOutput {
  readonly mesh: MeshData;
}

export interface CreateRouteInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly tags?: [];
  readonly virtualRouterName: string;
}

export interface CreateRouteOutput {
  readonly route: RouteData;
}

export interface CreateVirtualGatewayInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualGatewaySpec;
  readonly tags?: [];
  readonly virtualGatewayName: string;
}

export interface CreateVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

export interface CreateVirtualNodeInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualNodeSpec;
  readonly tags?: [];
  readonly virtualNodeName: string;
}

export interface CreateVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

export interface CreateVirtualRouterInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualRouterSpec;
  readonly tags?: [];
  readonly virtualRouterName: string;
}

export interface CreateVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

export interface CreateVirtualServiceInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualServiceSpec;
  readonly tags?: [];
  readonly virtualServiceName: string;
}

export interface CreateVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

export interface DeleteGatewayRouteInput {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DeleteGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

export interface DeleteMeshInput {
  readonly meshName: string;
}

export interface DeleteMeshOutput {
  readonly mesh: MeshData;
}

export interface DeleteRouteInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

export interface DeleteRouteOutput {
  readonly route: RouteData;
}

export interface DeleteVirtualGatewayInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DeleteVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

export interface DeleteVirtualNodeInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualNodeName: string;
}

export interface DeleteVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

export interface DeleteVirtualRouterInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualRouterName: string;
}

export interface DeleteVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

export interface DeleteVirtualServiceInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualServiceName: string;
}

export interface DeleteVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

export interface DescribeGatewayRouteInput {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DescribeGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

export interface DescribeMeshInput {
  readonly meshName: string;
  readonly meshOwner?: string;
}

export interface DescribeMeshOutput {
  readonly mesh: MeshData;
}

export interface DescribeRouteInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly virtualRouterName: string;
}

export interface DescribeRouteOutput {
  readonly route: RouteData;
}

export interface DescribeVirtualGatewayInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualGatewayName: string;
}

export interface DescribeVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

export interface DescribeVirtualNodeInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualNodeName: string;
}

export interface DescribeVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

export interface DescribeVirtualRouterInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualRouterName: string;
}

export interface DescribeVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

export interface DescribeVirtualServiceInput {
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly virtualServiceName: string;
}

export interface DescribeVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

export interface DnsServiceDiscovery {
  readonly hostname: string;
  readonly responseType?: string;
}

export interface Duration {
  readonly unit?: string;
  readonly value?: number;
}

export interface EgressFilter {
  readonly type: string;
}

export interface FileAccessLog {
  readonly path: string;
}

export interface ForbiddenException {
  readonly message?: string;
}

export interface GatewayRouteData {
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: GatewayRouteSpec;
  readonly status: GatewayRouteStatus;
  readonly virtualGatewayName: string;
}

export interface GatewayRouteHostnameMatch {
  readonly exact?: string;
  readonly suffix?: string;
}

export interface GatewayRouteHostnameRewrite {
  readonly defaultTargetHostname?: string;
}

export interface GatewayRouteRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly gatewayRouteName: string;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualGatewayName: string;
}

export interface GatewayRouteSpec {
  readonly grpcRoute?: GrpcGatewayRoute;
  readonly http2Route?: HttpGatewayRoute;
  readonly httpRoute?: HttpGatewayRoute;
  readonly priority?: number;
}

export interface GatewayRouteStatus {
  readonly status: string;
}

export interface GatewayRouteTarget {
  readonly virtualService: GatewayRouteVirtualService;
}

export interface GatewayRouteVirtualService {
  readonly virtualServiceName: string;
}

export interface GrpcGatewayRoute {
  readonly action: GrpcGatewayRouteAction;
  readonly match: GrpcGatewayRouteMatch;
}

export interface GrpcGatewayRouteAction {
  readonly rewrite?: GrpcGatewayRouteRewrite;
  readonly target: GatewayRouteTarget;
}

export interface GrpcGatewayRouteMatch {
  readonly hostname?: GatewayRouteHostnameMatch;
  readonly metadata?: [];
  readonly serviceName?: string;
}

export interface GrpcGatewayRouteMetadata {
  readonly invert?: boolean;
  readonly match?: GrpcMetadataMatchMethod;
  readonly name: string;
}

export interface GrpcGatewayRouteRewrite {
  readonly hostname?: GatewayRouteHostnameRewrite;
}

export interface GrpcMetadataMatchMethod {
  readonly exact?: string;
  readonly prefix?: string;
  readonly range?: MatchRange;
  readonly regex?: string;
  readonly suffix?: string;
}

export interface GrpcRetryPolicy {
  readonly grpcRetryEvents?: [];
  readonly httpRetryEvents?: [];
  readonly maxRetries: number;
  readonly perRetryTimeout: Duration;
  readonly tcpRetryEvents?: [];
}

export interface GrpcRoute {
  readonly action: GrpcRouteAction;
  readonly match: GrpcRouteMatch;
  readonly retryPolicy?: GrpcRetryPolicy;
  readonly timeout?: GrpcTimeout;
}

export interface GrpcRouteAction {
  readonly weightedTargets: [];
}

export interface GrpcRouteMatch {
  readonly metadata?: [];
  readonly methodName?: string;
  readonly serviceName?: string;
}

export interface GrpcRouteMetadata {
  readonly invert?: boolean;
  readonly match?: GrpcRouteMetadataMatchMethod;
  readonly name: string;
}

export interface GrpcRouteMetadataMatchMethod {
  readonly exact?: string;
  readonly prefix?: string;
  readonly range?: MatchRange;
  readonly regex?: string;
  readonly suffix?: string;
}

export interface GrpcTimeout {
  readonly idle?: Duration;
  readonly perRequest?: Duration;
}

export interface HeaderMatchMethod {
  readonly exact?: string;
  readonly prefix?: string;
  readonly range?: MatchRange;
  readonly regex?: string;
  readonly suffix?: string;
}

export interface HealthCheckPolicy {
  readonly healthyThreshold: number;
  readonly intervalMillis: number;
  readonly path?: string;
  readonly port?: number;
  readonly protocol: string;
  readonly timeoutMillis: number;
  readonly unhealthyThreshold: number;
}

export interface HttpGatewayRoute {
  readonly action: HttpGatewayRouteAction;
  readonly match: HttpGatewayRouteMatch;
}

export interface HttpGatewayRouteAction {
  readonly rewrite?: HttpGatewayRouteRewrite;
  readonly target: GatewayRouteTarget;
}

export interface HttpGatewayRouteHeader {
  readonly invert?: boolean;
  readonly match?: HeaderMatchMethod;
  readonly name: string;
}

export interface HttpGatewayRouteMatch {
  readonly headers?: [];
  readonly hostname?: GatewayRouteHostnameMatch;
  readonly method?: string;
  readonly path?: HttpPathMatch;
  readonly prefix?: string;
  readonly queryParameters?: [];
}

export interface HttpGatewayRoutePathRewrite {
  readonly exact?: string;
}

export interface HttpGatewayRoutePrefixRewrite {
  readonly defaultPrefix?: string;
  readonly value?: string;
}

export interface HttpGatewayRouteRewrite {
  readonly hostname?: GatewayRouteHostnameRewrite;
  readonly path?: HttpGatewayRoutePathRewrite;
  readonly prefix?: HttpGatewayRoutePrefixRewrite;
}

export interface HttpPathMatch {
  readonly exact?: string;
  readonly regex?: string;
}

export interface HttpQueryParameter {
  readonly match?: QueryParameterMatch;
  readonly name: string;
}

export interface HttpRetryPolicy {
  readonly httpRetryEvents?: [];
  readonly maxRetries: number;
  readonly perRetryTimeout: Duration;
  readonly tcpRetryEvents?: [];
}

export interface HttpRoute {
  readonly action: HttpRouteAction;
  readonly match: HttpRouteMatch;
  readonly retryPolicy?: HttpRetryPolicy;
  readonly timeout?: HttpTimeout;
}

export interface HttpRouteAction {
  readonly weightedTargets: [];
}

export interface HttpRouteHeader {
  readonly invert?: boolean;
  readonly match?: HeaderMatchMethod;
  readonly name: string;
}

export interface HttpRouteMatch {
  readonly headers?: [];
  readonly method?: string;
  readonly path?: HttpPathMatch;
  readonly prefix?: string;
  readonly queryParameters?: [];
  readonly scheme?: string;
}

export interface HttpTimeout {
  readonly idle?: Duration;
  readonly perRequest?: Duration;
}

export interface InternalServerErrorException {
  readonly message?: string;
}

export interface LimitExceededException {
  readonly message?: string;
}

export interface ListGatewayRoutesInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
  readonly virtualGatewayName: string;
}

export interface ListGatewayRoutesOutput {
  readonly gatewayRoutes: [];
  readonly nextToken?: string;
}

export interface ListMeshesInput {
  readonly limit?: number;
  readonly nextToken?: string;
}

export interface ListMeshesOutput {
  readonly meshes: [];
  readonly nextToken?: string;
}

export interface ListRoutesInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
  readonly virtualRouterName: string;
}

export interface ListRoutesOutput {
  readonly nextToken?: string;
  readonly routes: [];
}

export interface ListTagsForResourceInput {
  readonly limit?: number;
  readonly nextToken?: string;
  readonly resourceArn: string;
}

export interface ListTagsForResourceOutput {
  readonly nextToken?: string;
  readonly tags: [];
}

export interface ListVirtualGatewaysInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualGatewaysOutput {
  readonly nextToken?: string;
  readonly virtualGateways: [];
}

export interface ListVirtualNodesInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualNodesOutput {
  readonly nextToken?: string;
  readonly virtualNodes: [];
}

export interface ListVirtualRoutersInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualRoutersOutput {
  readonly nextToken?: string;
  readonly virtualRouters: [];
}

export interface ListVirtualServicesInput {
  readonly limit?: number;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly nextToken?: string;
}

export interface ListVirtualServicesOutput {
  readonly nextToken?: string;
  readonly virtualServices: [];
}

export interface Listener {
  readonly connectionPool?: VirtualNodeConnectionPool;
  readonly healthCheck?: HealthCheckPolicy;
  readonly outlierDetection?: OutlierDetection;
  readonly portMapping: PortMapping;
  readonly timeout?: ListenerTimeout;
  readonly tls?: ListenerTls;
}

export interface ListenerTimeout {
  readonly grpc?: GrpcTimeout;
  readonly http?: HttpTimeout;
  readonly http2?: HttpTimeout;
  readonly tcp?: TcpTimeout;
}

export interface ListenerTls {
  readonly certificate: ListenerTlsCertificate;
  readonly mode: string;
  readonly validation?: ListenerTlsValidationContext;
}

export interface ListenerTlsAcmCertificate {
  readonly certificateArn: string;
}

export interface ListenerTlsCertificate {
  readonly acm?: ListenerTlsAcmCertificate;
  readonly file?: ListenerTlsFileCertificate;
  readonly sds?: ListenerTlsSdsCertificate;
}

export interface ListenerTlsFileCertificate {
  readonly certificateChain: string;
  readonly privateKey: string;
}

export interface ListenerTlsSdsCertificate {
  readonly secretName: string;
}

export interface ListenerTlsValidationContext {
  readonly subjectAlternativeNames?: SubjectAlternativeNames;
  readonly trust: ListenerTlsValidationContextTrust;
}

export interface ListenerTlsValidationContextTrust {
  readonly file?: TlsValidationContextFileTrust;
  readonly sds?: TlsValidationContextSdsTrust;
}

export interface Logging {
  readonly accessLog?: AccessLog;
}

export interface MatchRange {
  readonly end: number;
  readonly start: number;
}

export interface MeshData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: MeshSpec;
  readonly status: MeshStatus;
}

export interface MeshRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
}

export interface MeshSpec {
  readonly egressFilter?: EgressFilter;
}

export interface MeshStatus {
  readonly status?: string;
}

export interface NotFoundException {
  readonly message?: string;
}

export interface OutlierDetection {
  readonly baseEjectionDuration: Duration;
  readonly interval: Duration;
  readonly maxEjectionPercent: number;
  readonly maxServerErrors: number;
}

export interface PortMapping {
  readonly port: number;
  readonly protocol: string;
}

export interface QueryParameterMatch {
  readonly exact?: string;
}

export interface ResourceInUseException {
  readonly message?: string;
}

export interface ResourceMetadata {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly uid: string;
  readonly version: number;
}

export interface RouteData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly status: RouteStatus;
  readonly virtualRouterName: string;
}

export interface RouteRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly routeName: string;
  readonly version: number;
  readonly virtualRouterName: string;
}

export interface RouteSpec {
  readonly grpcRoute?: GrpcRoute;
  readonly http2Route?: HttpRoute;
  readonly httpRoute?: HttpRoute;
  readonly priority?: number;
  readonly tcpRoute?: TcpRoute;
}

export interface RouteStatus {
  readonly status: string;
}

export interface ServiceDiscovery {
  readonly awsCloudMap?: AwsCloudMapServiceDiscovery;
  readonly dns?: DnsServiceDiscovery;
}

export interface ServiceUnavailableException {
  readonly message?: string;
}

export interface SubjectAlternativeNameMatchers {
  readonly exact: [];
}

export interface SubjectAlternativeNames {
  readonly match: SubjectAlternativeNameMatchers;
}

export interface TagRef {
  readonly key: string;
  readonly value: string;
}

export interface TagResourceInput {
  readonly resourceArn: string;
  readonly tags: [];
}

export interface TagResourceOutput {
}

export interface TcpRoute {
  readonly action: TcpRouteAction;
  readonly timeout?: TcpTimeout;
}

export interface TcpRouteAction {
  readonly weightedTargets: [];
}

export interface TcpTimeout {
  readonly idle?: Duration;
}

export interface TlsValidationContext {
  readonly subjectAlternativeNames?: SubjectAlternativeNames;
  readonly trust: TlsValidationContextTrust;
}

export interface TlsValidationContextAcmTrust {
  readonly certificateAuthorityArns: [];
}

export interface TlsValidationContextFileTrust {
  readonly certificateChain: string;
}

export interface TlsValidationContextSdsTrust {
  readonly secretName: string;
}

export interface TlsValidationContextTrust {
  readonly acm?: TlsValidationContextAcmTrust;
  readonly file?: TlsValidationContextFileTrust;
  readonly sds?: TlsValidationContextSdsTrust;
}

export interface TooManyRequestsException {
  readonly message?: string;
}

export interface TooManyTagsException {
  readonly message?: string;
}

export interface UntagResourceInput {
  readonly resourceArn: string;
  readonly tagKeys: [];
}

export interface UntagResourceOutput {
}

export interface UpdateGatewayRouteInput {
  readonly clientToken?: string;
  readonly gatewayRouteName: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: GatewayRouteSpec;
  readonly virtualGatewayName: string;
}

export interface UpdateGatewayRouteOutput {
  readonly gatewayRoute: GatewayRouteData;
}

export interface UpdateMeshInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly spec?: MeshSpec;
}

export interface UpdateMeshOutput {
  readonly mesh: MeshData;
}

export interface UpdateRouteInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly routeName: string;
  readonly spec: RouteSpec;
  readonly virtualRouterName: string;
}

export interface UpdateRouteOutput {
  readonly route: RouteData;
}

export interface UpdateVirtualGatewayInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualGatewaySpec;
  readonly virtualGatewayName: string;
}

export interface UpdateVirtualGatewayOutput {
  readonly virtualGateway: VirtualGatewayData;
}

export interface UpdateVirtualNodeInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualNodeSpec;
  readonly virtualNodeName: string;
}

export interface UpdateVirtualNodeOutput {
  readonly virtualNode: VirtualNodeData;
}

export interface UpdateVirtualRouterInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualRouterSpec;
  readonly virtualRouterName: string;
}

export interface UpdateVirtualRouterOutput {
  readonly virtualRouter: VirtualRouterData;
}

export interface UpdateVirtualServiceInput {
  readonly clientToken?: string;
  readonly meshName: string;
  readonly meshOwner?: string;
  readonly spec: VirtualServiceSpec;
  readonly virtualServiceName: string;
}

export interface UpdateVirtualServiceOutput {
  readonly virtualService: VirtualServiceData;
}

export interface VirtualGatewayAccessLog {
  readonly file?: VirtualGatewayFileAccessLog;
}

export interface VirtualGatewayBackendDefaults {
  readonly clientPolicy?: VirtualGatewayClientPolicy;
}

export interface VirtualGatewayClientPolicy {
  readonly tls?: VirtualGatewayClientPolicyTls;
}

export interface VirtualGatewayClientPolicyTls {
  readonly certificate?: VirtualGatewayClientTlsCertificate;
  readonly enforce?: boolean;
  readonly ports?: [];
  readonly validation: VirtualGatewayTlsValidationContext;
}

export interface VirtualGatewayClientTlsCertificate {
  readonly file?: VirtualGatewayListenerTlsFileCertificate;
  readonly sds?: VirtualGatewayListenerTlsSdsCertificate;
}

export interface VirtualGatewayConnectionPool {
  readonly grpc?: VirtualGatewayGrpcConnectionPool;
  readonly http?: VirtualGatewayHttpConnectionPool;
  readonly http2?: VirtualGatewayHttp2ConnectionPool;
}

export interface VirtualGatewayData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualGatewaySpec;
  readonly status: VirtualGatewayStatus;
  readonly virtualGatewayName: string;
}

export interface VirtualGatewayFileAccessLog {
  readonly path: string;
}

export interface VirtualGatewayGrpcConnectionPool {
  readonly maxRequests: number;
}

export interface VirtualGatewayHealthCheckPolicy {
  readonly healthyThreshold: number;
  readonly intervalMillis: number;
  readonly path?: string;
  readonly port?: number;
  readonly protocol: string;
  readonly timeoutMillis: number;
  readonly unhealthyThreshold: number;
}

export interface VirtualGatewayHttp2ConnectionPool {
  readonly maxRequests: number;
}

export interface VirtualGatewayHttpConnectionPool {
  readonly maxConnections: number;
  readonly maxPendingRequests?: number;
}

export interface VirtualGatewayListener {
  readonly connectionPool?: VirtualGatewayConnectionPool;
  readonly healthCheck?: VirtualGatewayHealthCheckPolicy;
  readonly portMapping: VirtualGatewayPortMapping;
  readonly tls?: VirtualGatewayListenerTls;
}

export interface VirtualGatewayListenerTls {
  readonly certificate: VirtualGatewayListenerTlsCertificate;
  readonly mode: string;
  readonly validation?: VirtualGatewayListenerTlsValidationContext;
}

export interface VirtualGatewayListenerTlsAcmCertificate {
  readonly certificateArn: string;
}

export interface VirtualGatewayListenerTlsCertificate {
  readonly acm?: VirtualGatewayListenerTlsAcmCertificate;
  readonly file?: VirtualGatewayListenerTlsFileCertificate;
  readonly sds?: VirtualGatewayListenerTlsSdsCertificate;
}

export interface VirtualGatewayListenerTlsFileCertificate {
  readonly certificateChain: string;
  readonly privateKey: string;
}

export interface VirtualGatewayListenerTlsSdsCertificate {
  readonly secretName: string;
}

export interface VirtualGatewayListenerTlsValidationContext {
  readonly subjectAlternativeNames?: SubjectAlternativeNames;
  readonly trust: VirtualGatewayListenerTlsValidationContextTrust;
}

export interface VirtualGatewayListenerTlsValidationContextTrust {
  readonly file?: VirtualGatewayTlsValidationContextFileTrust;
  readonly sds?: VirtualGatewayTlsValidationContextSdsTrust;
}

export interface VirtualGatewayLogging {
  readonly accessLog?: VirtualGatewayAccessLog;
}

export interface VirtualGatewayPortMapping {
  readonly port: number;
  readonly protocol: string;
}

export interface VirtualGatewayRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualGatewayName: string;
}

export interface VirtualGatewaySpec {
  readonly backendDefaults?: VirtualGatewayBackendDefaults;
  readonly listeners: [];
  readonly logging?: VirtualGatewayLogging;
}

export interface VirtualGatewayStatus {
  readonly status: string;
}

export interface VirtualGatewayTlsValidationContext {
  readonly subjectAlternativeNames?: SubjectAlternativeNames;
  readonly trust: VirtualGatewayTlsValidationContextTrust;
}

export interface VirtualGatewayTlsValidationContextAcmTrust {
  readonly certificateAuthorityArns: [];
}

export interface VirtualGatewayTlsValidationContextFileTrust {
  readonly certificateChain: string;
}

export interface VirtualGatewayTlsValidationContextSdsTrust {
  readonly secretName: string;
}

export interface VirtualGatewayTlsValidationContextTrust {
  readonly acm?: VirtualGatewayTlsValidationContextAcmTrust;
  readonly file?: VirtualGatewayTlsValidationContextFileTrust;
  readonly sds?: VirtualGatewayTlsValidationContextSdsTrust;
}

export interface VirtualNodeConnectionPool {
  readonly grpc?: VirtualNodeGrpcConnectionPool;
  readonly http?: VirtualNodeHttpConnectionPool;
  readonly http2?: VirtualNodeHttp2ConnectionPool;
  readonly tcp?: VirtualNodeTcpConnectionPool;
}

export interface VirtualNodeData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualNodeSpec;
  readonly status: VirtualNodeStatus;
  readonly virtualNodeName: string;
}

export interface VirtualNodeGrpcConnectionPool {
  readonly maxRequests: number;
}

export interface VirtualNodeHttp2ConnectionPool {
  readonly maxRequests: number;
}

export interface VirtualNodeHttpConnectionPool {
  readonly maxConnections: number;
  readonly maxPendingRequests?: number;
}

export interface VirtualNodeRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualNodeName: string;
}

export interface VirtualNodeServiceProvider {
  readonly virtualNodeName: string;
}

export interface VirtualNodeSpec {
  readonly backendDefaults?: BackendDefaults;
  readonly backends?: [];
  readonly listeners?: [];
  readonly logging?: Logging;
  readonly serviceDiscovery?: ServiceDiscovery;
}

export interface VirtualNodeStatus {
  readonly status: string;
}

export interface VirtualNodeTcpConnectionPool {
  readonly maxConnections: number;
}

export interface VirtualRouterData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualRouterSpec;
  readonly status: VirtualRouterStatus;
  readonly virtualRouterName: string;
}

export interface VirtualRouterListener {
  readonly portMapping: PortMapping;
}

export interface VirtualRouterRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualRouterName: string;
}

export interface VirtualRouterServiceProvider {
  readonly virtualRouterName: string;
}

export interface VirtualRouterSpec {
  readonly listeners?: [];
}

export interface VirtualRouterStatus {
  readonly status: string;
}

export interface VirtualServiceBackend {
  readonly clientPolicy?: ClientPolicy;
  readonly virtualServiceName: string;
}

export interface VirtualServiceData {
  readonly meshName: string;
  readonly metadata: ResourceMetadata;
  readonly spec: VirtualServiceSpec;
  readonly status: VirtualServiceStatus;
  readonly virtualServiceName: string;
}

export interface VirtualServiceProvider {
  readonly virtualNode?: VirtualNodeServiceProvider;
  readonly virtualRouter?: VirtualRouterServiceProvider;
}

export interface VirtualServiceRef {
  readonly arn: string;
  readonly createdAt: Date;
  readonly lastUpdatedAt: Date;
  readonly meshName: string;
  readonly meshOwner: string;
  readonly resourceOwner: string;
  readonly version: number;
  readonly virtualServiceName: string;
}

export interface VirtualServiceSpec {
  readonly provider?: VirtualServiceProvider;
}

export interface VirtualServiceStatus {
  readonly status: string;
}

export interface WeightedTarget {
  readonly virtualNode: string;
  readonly weight: number;
}


