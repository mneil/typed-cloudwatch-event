/**
 * STOP. This file is autogenerated. DO NOT EDIT by hand
 */
export interface DeleteLexicon {
  readonly Name: string;
}
export interface DescribeVoices {
  readonly Engine?: string;
  readonly LanguageCode?: string;
  readonly IncludeAdditionalLanguageCodes?: boolean;
  readonly NextToken?: string;
}
export interface GetLexicon {
  readonly Name: string;
}
export interface GetSpeechSynthesisTask {
  readonly TaskId: string;
}
export interface ListLexicons {
  readonly NextToken?: string;
}
export interface ListSpeechSynthesisTasks {
  readonly MaxResults?: number;
  readonly NextToken?: string;
  readonly Status?: string;
}
export interface PutLexicon {
  readonly Name: string;
  readonly Content: string;
}
export interface StartSpeechSynthesisTask {
  readonly Engine?: string;
  readonly LanguageCode?: string;
  readonly LexiconNames?: [];
  readonly OutputFormat: string;
  readonly OutputS3BucketName: string;
  readonly OutputS3KeyPrefix?: string;
  readonly SampleRate?: string;
  readonly SnsTopicArn?: string;
  readonly SpeechMarkTypes?: [];
  readonly Text: string;
  readonly TextType?: string;
  readonly VoiceId: string;
}
export interface SynthesizeSpeech {
  readonly Engine?: string;
  readonly LanguageCode?: string;
  readonly LexiconNames?: [];
  readonly OutputFormat: string;
  readonly SampleRate?: string;
  readonly SpeechMarkTypes?: [];
  readonly Text: string;
  readonly TextType?: string;
  readonly VoiceId: string;
}



interface DeleteLexiconInput {
  readonly Name: string;
}

interface DeleteLexiconOutput {
}

interface DescribeVoicesInput {
  readonly Engine: string;
  readonly LanguageCode: string;
  readonly IncludeAdditionalLanguageCodes: boolean;
  readonly NextToken: string;
}

interface DescribeVoicesOutput {
  readonly Voices: [];
  readonly NextToken: string;
}

interface EngineNotSupportedException {
  readonly message: string;
}

interface GetLexiconInput {
  readonly Name: string;
}

interface GetLexiconOutput {
  readonly Lexicon: Lexicon;
  readonly LexiconAttributes: LexiconAttributes;
}

interface GetSpeechSynthesisTaskInput {
  readonly TaskId: string;
}

interface GetSpeechSynthesisTaskOutput {
  readonly SynthesisTask: SynthesisTask;
}

interface InvalidLexiconException {
  readonly message: string;
}

interface InvalidNextTokenException {
  readonly message: string;
}

interface InvalidS3BucketException {
  readonly message: string;
}

interface InvalidS3KeyException {
  readonly message: string;
}

interface InvalidSampleRateException {
  readonly message: string;
}

interface InvalidSnsTopicArnException {
  readonly message: string;
}

interface InvalidSsmlException {
  readonly message: string;
}

interface InvalidTaskIdException {
  readonly message: string;
}

interface LanguageNotSupportedException {
  readonly message: string;
}

interface Lexicon {
  readonly Content: string;
  readonly Name: string;
}

interface LexiconAttributes {
  readonly Alphabet: string;
  readonly LanguageCode: string;
  readonly LastModified: Date;
  readonly LexiconArn: string;
  readonly LexemesCount: number;
  readonly Size: number;
}

interface LexiconDescription {
  readonly Name: string;
  readonly Attributes: LexiconAttributes;
}

interface LexiconNotFoundException {
  readonly message: string;
}

interface LexiconSizeExceededException {
  readonly message: string;
}

interface ListLexiconsInput {
  readonly NextToken: string;
}

interface ListLexiconsOutput {
  readonly Lexicons: [];
  readonly NextToken: string;
}

interface ListSpeechSynthesisTasksInput {
  readonly MaxResults: number;
  readonly NextToken: string;
  readonly Status: string;
}

interface ListSpeechSynthesisTasksOutput {
  readonly NextToken: string;
  readonly SynthesisTasks: [];
}

interface MarksNotSupportedForFormatException {
  readonly message: string;
}

interface MaxLexemeLengthExceededException {
  readonly message: string;
}

interface MaxLexiconsNumberExceededException {
  readonly message: string;
}

interface PutLexiconInput {
  readonly Name: string;
  readonly Content: string;
}

interface PutLexiconOutput {
}

interface ServiceFailureException {
  readonly message: string;
}

interface SsmlMarksNotSupportedForTextTypeException {
  readonly message: string;
}

interface StartSpeechSynthesisTaskInput {
  readonly Engine: string;
  readonly LanguageCode: string;
  readonly LexiconNames: [];
  readonly OutputFormat: string;
  readonly OutputS3BucketName: string;
  readonly OutputS3KeyPrefix: string;
  readonly SampleRate: string;
  readonly SnsTopicArn: string;
  readonly SpeechMarkTypes: [];
  readonly Text: string;
  readonly TextType: string;
  readonly VoiceId: string;
}

interface StartSpeechSynthesisTaskOutput {
  readonly SynthesisTask: SynthesisTask;
}

interface SynthesisTask {
  readonly Engine: string;
  readonly TaskId: string;
  readonly TaskStatus: string;
  readonly TaskStatusReason: string;
  readonly OutputUri: string;
  readonly CreationTime: Date;
  readonly RequestCharacters: number;
  readonly SnsTopicArn: string;
  readonly LexiconNames: [];
  readonly OutputFormat: string;
  readonly SampleRate: string;
  readonly SpeechMarkTypes: [];
  readonly TextType: string;
  readonly VoiceId: string;
  readonly LanguageCode: string;
}

interface SynthesisTaskNotFoundException {
  readonly message: string;
}

interface SynthesizeSpeechInput {
  readonly Engine: string;
  readonly LanguageCode: string;
  readonly LexiconNames: [];
  readonly OutputFormat: string;
  readonly SampleRate: string;
  readonly SpeechMarkTypes: [];
  readonly Text: string;
  readonly TextType: string;
  readonly VoiceId: string;
}

interface SynthesizeSpeechOutput {
  readonly AudioStream: unknown;
  readonly ContentType: string;
  readonly RequestCharacters: number;
}

interface TextLengthExceededException {
  readonly message: string;
}

interface UnsupportedPlsAlphabetException {
  readonly message: string;
}

interface UnsupportedPlsLanguageException {
  readonly message: string;
}

interface Voice {
  readonly Gender: string;
  readonly Id: string;
  readonly LanguageCode: string;
  readonly LanguageName: string;
  readonly Name: string;
  readonly AdditionalLanguageCodes: [];
  readonly SupportedEngines: [];
}

