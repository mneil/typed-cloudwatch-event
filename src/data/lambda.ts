/**
 * STOP. This file is autogenerated. DO NOT EDIT by hand
 */
export interface AddLayerVersionPermission {
  readonly LayerName: string;
  readonly VersionNumber: number;
  readonly StatementId: string;
  readonly Action: string;
  readonly Principal: string;
  readonly OrganizationId?: string;
  readonly RevisionId?: string;
}
export interface AddPermission {
  readonly FunctionName: string;
  readonly StatementId: string;
  readonly Action: string;
  readonly Principal: string;
  readonly SourceArn?: string;
  readonly SourceAccount?: string;
  readonly EventSourceToken?: string;
  readonly Qualifier?: string;
  readonly RevisionId?: string;
}
export interface CreateAlias {
  readonly FunctionName: string;
  readonly Name: string;
  readonly FunctionVersion: string;
  readonly Description?: string;
  readonly RoutingConfig?: AliasRoutingConfiguration;
}
export interface CreateCodeSigningConfig {
  readonly Description?: string;
  readonly AllowedPublishers: AllowedPublishers;
  readonly CodeSigningPolicies?: CodeSigningPolicies;
}
export interface CreateEventSourceMapping {
  readonly EventSourceArn?: string;
  readonly FunctionName: string;
  readonly Enabled?: boolean;
  readonly BatchSize?: number;
  readonly FilterCriteria?: FilterCriteria;
  readonly MaximumBatchingWindowInSeconds?: number;
  readonly ParallelizationFactor?: number;
  readonly StartingPosition?: string;
  readonly StartingPositionTimestamp?: Date;
  readonly DestinationConfig?: DestinationConfig;
  readonly MaximumRecordAgeInSeconds?: number;
  readonly BisectBatchOnFunctionError?: boolean;
  readonly MaximumRetryAttempts?: number;
  readonly TumblingWindowInSeconds?: number;
  readonly Topics?: [];
  readonly Queues?: [];
  readonly SourceAccessConfigurations?: [];
  readonly SelfManagedEventSource?: SelfManagedEventSource;
  readonly FunctionResponseTypes?: [];
}
export interface CreateFunction {
  readonly FunctionName: string;
  readonly Runtime?: string;
  readonly Role: string;
  readonly Handler?: string;
  readonly Code: FunctionCode;
  readonly Description?: string;
  readonly Timeout?: number;
  readonly MemorySize?: number;
  readonly Publish?: boolean;
  readonly VpcConfig?: VpcConfig;
  readonly PackageType?: string;
  readonly DeadLetterConfig?: DeadLetterConfig;
  readonly Environment?: Environment;
  readonly KMSKeyArn?: string;
  readonly TracingConfig?: TracingConfig;
  readonly Tags?: {[key: string]: any};
  readonly Layers?: [];
  readonly FileSystemConfigs?: [];
  readonly ImageConfig?: ImageConfig;
  readonly CodeSigningConfigArn?: string;
  readonly Architectures?: [];
}
export interface DeleteAlias {
  readonly FunctionName: string;
  readonly Name: string;
}
export interface DeleteCodeSigningConfig {
  readonly CodeSigningConfigArn: string;
}
export interface DeleteEventSourceMapping {
  readonly UUID: string;
}
export interface DeleteFunction {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface DeleteFunctionCodeSigningConfig {
  readonly FunctionName: string;
}
export interface DeleteFunctionConcurrency {
  readonly FunctionName: string;
}
export interface DeleteFunctionEventInvokeConfig {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface DeleteLayerVersion {
  readonly LayerName: string;
  readonly VersionNumber: number;
}
export interface DeleteProvisionedConcurrencyConfig {
  readonly FunctionName: string;
  readonly Qualifier: string;
}
export interface GetAccountSettings {
}
export interface GetAlias {
  readonly FunctionName: string;
  readonly Name: string;
}
export interface GetCodeSigningConfig {
  readonly CodeSigningConfigArn: string;
}
export interface GetEventSourceMapping {
  readonly UUID: string;
}
export interface GetFunction {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface GetFunctionCodeSigningConfig {
  readonly FunctionName: string;
}
export interface GetFunctionConcurrency {
  readonly FunctionName: string;
}
export interface GetFunctionConfiguration {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface GetFunctionEventInvokeConfig {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface GetLayerVersion {
  readonly LayerName: string;
  readonly VersionNumber: number;
}
export interface GetLayerVersionByArn {
  readonly Arn: string;
}
export interface GetLayerVersionPolicy {
  readonly LayerName: string;
  readonly VersionNumber: number;
}
export interface GetPolicy {
  readonly FunctionName: string;
  readonly Qualifier?: string;
}
export interface GetProvisionedConcurrencyConfig {
  readonly FunctionName: string;
  readonly Qualifier: string;
}
export interface Invoke {
  readonly FunctionName: string;
  readonly InvocationType?: string;
  readonly LogType?: string;
  readonly ClientContext?: string;
  readonly Payload?: unknown;
  readonly Qualifier?: string;
}
export interface InvokeAsync {
  readonly FunctionName: string;
  readonly InvokeArgs: unknown;
}
export interface ListAliases {
  readonly FunctionName: string;
  readonly FunctionVersion?: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListCodeSigningConfigs {
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListEventSourceMappings {
  readonly EventSourceArn?: string;
  readonly FunctionName?: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListFunctionEventInvokeConfigs {
  readonly FunctionName: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListFunctions {
  readonly MasterRegion?: string;
  readonly FunctionVersion?: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListFunctionsByCodeSigningConfig {
  readonly CodeSigningConfigArn: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListLayerVersions {
  readonly CompatibleRuntime?: string;
  readonly LayerName: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
  readonly CompatibleArchitecture?: string;
}
export interface ListLayers {
  readonly CompatibleRuntime?: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
  readonly CompatibleArchitecture?: string;
}
export interface ListProvisionedConcurrencyConfigs {
  readonly FunctionName: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface ListTags {
  readonly Resource: string;
}
export interface ListVersionsByFunction {
  readonly FunctionName: string;
  readonly Marker?: string;
  readonly MaxItems?: number;
}
export interface PublishLayerVersion {
  readonly LayerName: string;
  readonly Description?: string;
  readonly Content: LayerVersionContentInput;
  readonly CompatibleRuntimes?: [];
  readonly LicenseInfo?: string;
  readonly CompatibleArchitectures?: [];
}
export interface PublishVersion {
  readonly FunctionName: string;
  readonly CodeSha256?: string;
  readonly Description?: string;
  readonly RevisionId?: string;
}
export interface PutFunctionCodeSigningConfig {
  readonly CodeSigningConfigArn: string;
  readonly FunctionName: string;
}
export interface PutFunctionConcurrency {
  readonly FunctionName: string;
  readonly ReservedConcurrentExecutions: number;
}
export interface PutFunctionEventInvokeConfig {
  readonly FunctionName: string;
  readonly Qualifier?: string;
  readonly MaximumRetryAttempts?: number;
  readonly MaximumEventAgeInSeconds?: number;
  readonly DestinationConfig?: DestinationConfig;
}
export interface PutProvisionedConcurrencyConfig {
  readonly FunctionName: string;
  readonly Qualifier: string;
  readonly ProvisionedConcurrentExecutions: number;
}
export interface RemoveLayerVersionPermission {
  readonly LayerName: string;
  readonly VersionNumber: number;
  readonly StatementId: string;
  readonly RevisionId?: string;
}
export interface RemovePermission {
  readonly FunctionName: string;
  readonly StatementId: string;
  readonly Qualifier?: string;
  readonly RevisionId?: string;
}
export interface TagResource {
  readonly Resource: string;
  readonly Tags: {[key: string]: any};
}
export interface UntagResource {
  readonly Resource: string;
  readonly TagKeys: [];
}
export interface UpdateAlias {
  readonly FunctionName: string;
  readonly Name: string;
  readonly FunctionVersion?: string;
  readonly Description?: string;
  readonly RoutingConfig?: AliasRoutingConfiguration;
  readonly RevisionId?: string;
}
export interface UpdateCodeSigningConfig {
  readonly CodeSigningConfigArn: string;
  readonly Description?: string;
  readonly AllowedPublishers?: AllowedPublishers;
  readonly CodeSigningPolicies?: CodeSigningPolicies;
}
export interface UpdateEventSourceMapping {
  readonly UUID: string;
  readonly FunctionName?: string;
  readonly Enabled?: boolean;
  readonly BatchSize?: number;
  readonly FilterCriteria?: FilterCriteria;
  readonly MaximumBatchingWindowInSeconds?: number;
  readonly DestinationConfig?: DestinationConfig;
  readonly MaximumRecordAgeInSeconds?: number;
  readonly BisectBatchOnFunctionError?: boolean;
  readonly MaximumRetryAttempts?: number;
  readonly ParallelizationFactor?: number;
  readonly SourceAccessConfigurations?: [];
  readonly TumblingWindowInSeconds?: number;
  readonly FunctionResponseTypes?: [];
}
export interface UpdateFunctionCode {
  readonly FunctionName: string;
  readonly ZipFile?: unknown;
  readonly S3Bucket?: string;
  readonly S3Key?: string;
  readonly S3ObjectVersion?: string;
  readonly ImageUri?: string;
  readonly Publish?: boolean;
  readonly DryRun?: boolean;
  readonly RevisionId?: string;
  readonly Architectures?: [];
}
export interface UpdateFunctionConfiguration {
  readonly FunctionName: string;
  readonly Role?: string;
  readonly Handler?: string;
  readonly Description?: string;
  readonly Timeout?: number;
  readonly MemorySize?: number;
  readonly VpcConfig?: VpcConfig;
  readonly Environment?: Environment;
  readonly Runtime?: string;
  readonly DeadLetterConfig?: DeadLetterConfig;
  readonly KMSKeyArn?: string;
  readonly TracingConfig?: TracingConfig;
  readonly RevisionId?: string;
  readonly Layers?: [];
  readonly FileSystemConfigs?: [];
  readonly ImageConfig?: ImageConfig;
}
export interface UpdateFunctionEventInvokeConfig {
  readonly FunctionName: string;
  readonly Qualifier?: string;
  readonly MaximumRetryAttempts?: number;
  readonly MaximumEventAgeInSeconds?: number;
  readonly DestinationConfig?: DestinationConfig;
}



interface AccountLimit {
  readonly TotalCodeSize: number;
  readonly CodeSizeUnzipped: number;
  readonly CodeSizeZipped: number;
  readonly ConcurrentExecutions: number;
  readonly UnreservedConcurrentExecutions: number;
}

interface AccountUsage {
  readonly TotalCodeSize: number;
  readonly FunctionCount: number;
}

interface AddLayerVersionPermissionRequest {
  readonly LayerName: string;
  readonly VersionNumber: number;
  readonly StatementId: string;
  readonly Action: string;
  readonly Principal: string;
  readonly OrganizationId: string;
  readonly RevisionId: string;
}

interface AddLayerVersionPermissionResponse {
  readonly Statement: string;
  readonly RevisionId: string;
}

interface AddPermissionRequest {
  readonly FunctionName: string;
  readonly StatementId: string;
  readonly Action: string;
  readonly Principal: string;
  readonly SourceArn: string;
  readonly SourceAccount: string;
  readonly EventSourceToken: string;
  readonly Qualifier: string;
  readonly RevisionId: string;
}

interface AddPermissionResponse {
  readonly Statement: string;
}

interface AliasConfiguration {
  readonly AliasArn: string;
  readonly Name: string;
  readonly FunctionVersion: string;
  readonly Description: string;
  readonly RoutingConfig: AliasRoutingConfiguration;
  readonly RevisionId: string;
}

interface AliasRoutingConfiguration {
  readonly AdditionalVersionWeights: {[key: string]: any};
}

interface AllowedPublishers {
  readonly SigningProfileVersionArns: [];
}

interface CodeSigningConfig {
  readonly CodeSigningConfigId: string;
  readonly CodeSigningConfigArn: string;
  readonly Description: string;
  readonly AllowedPublishers: AllowedPublishers;
  readonly CodeSigningPolicies: CodeSigningPolicies;
  readonly LastModified: string;
}

interface CodeSigningConfigNotFoundException {
  readonly Type: string;
  readonly Message: string;
}

interface CodeSigningPolicies {
  readonly UntrustedArtifactOnDeployment: string;
}

interface CodeStorageExceededException {
  readonly Type: string;
  readonly message: string;
}

interface CodeVerificationFailedException {
  readonly Type: string;
  readonly Message: string;
}

interface Concurrency {
  readonly ReservedConcurrentExecutions: number;
}

interface CreateAliasRequest {
  readonly FunctionName: string;
  readonly Name: string;
  readonly FunctionVersion: string;
  readonly Description: string;
  readonly RoutingConfig: AliasRoutingConfiguration;
}

interface CreateCodeSigningConfigRequest {
  readonly Description: string;
  readonly AllowedPublishers: AllowedPublishers;
  readonly CodeSigningPolicies: CodeSigningPolicies;
}

interface CreateCodeSigningConfigResponse {
  readonly CodeSigningConfig: CodeSigningConfig;
}

interface CreateEventSourceMappingRequest {
  readonly EventSourceArn: string;
  readonly FunctionName: string;
  readonly Enabled: boolean;
  readonly BatchSize: number;
  readonly FilterCriteria: FilterCriteria;
  readonly MaximumBatchingWindowInSeconds: number;
  readonly ParallelizationFactor: number;
  readonly StartingPosition: string;
  readonly StartingPositionTimestamp: Date;
  readonly DestinationConfig: DestinationConfig;
  readonly MaximumRecordAgeInSeconds: number;
  readonly BisectBatchOnFunctionError: boolean;
  readonly MaximumRetryAttempts: number;
  readonly TumblingWindowInSeconds: number;
  readonly Topics: [];
  readonly Queues: [];
  readonly SourceAccessConfigurations: [];
  readonly SelfManagedEventSource: SelfManagedEventSource;
  readonly FunctionResponseTypes: [];
}

interface CreateFunctionRequest {
  readonly FunctionName: string;
  readonly Runtime: string;
  readonly Role: string;
  readonly Handler: string;
  readonly Code: FunctionCode;
  readonly Description: string;
  readonly Timeout: number;
  readonly MemorySize: number;
  readonly Publish: boolean;
  readonly VpcConfig: VpcConfig;
  readonly PackageType: string;
  readonly DeadLetterConfig: DeadLetterConfig;
  readonly Environment: Environment;
  readonly KMSKeyArn: string;
  readonly TracingConfig: TracingConfig;
  readonly Tags: {[key: string]: any};
  readonly Layers: [];
  readonly FileSystemConfigs: [];
  readonly ImageConfig: ImageConfig;
  readonly CodeSigningConfigArn: string;
  readonly Architectures: [];
}

interface DeadLetterConfig {
  readonly TargetArn: string;
}

interface DeleteAliasRequest {
  readonly FunctionName: string;
  readonly Name: string;
}

interface DeleteCodeSigningConfigRequest {
  readonly CodeSigningConfigArn: string;
}

interface DeleteCodeSigningConfigResponse {
}

interface DeleteEventSourceMappingRequest {
  readonly UUID: string;
}

interface DeleteFunctionCodeSigningConfigRequest {
  readonly FunctionName: string;
}

interface DeleteFunctionConcurrencyRequest {
  readonly FunctionName: string;
}

interface DeleteFunctionEventInvokeConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface DeleteFunctionRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface DeleteLayerVersionRequest {
  readonly LayerName: string;
  readonly VersionNumber: number;
}

interface DeleteProvisionedConcurrencyConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface DestinationConfig {
  readonly OnSuccess: OnSuccess;
  readonly OnFailure: OnFailure;
}

interface EC2AccessDeniedException {
  readonly Type: string;
  readonly Message: string;
}

interface EC2ThrottledException {
  readonly Type: string;
  readonly Message: string;
}

interface EC2UnexpectedException {
  readonly Type: string;
  readonly Message: string;
  readonly EC2ErrorCode: string;
}

interface EFSIOException {
  readonly Type: string;
  readonly Message: string;
}

interface EFSMountConnectivityException {
  readonly Type: string;
  readonly Message: string;
}

interface EFSMountFailureException {
  readonly Type: string;
  readonly Message: string;
}

interface EFSMountTimeoutException {
  readonly Type: string;
  readonly Message: string;
}

interface ENILimitReachedException {
  readonly Type: string;
  readonly Message: string;
}

interface Environment {
  readonly Variables: {[key: string]: any};
}

interface EnvironmentError {
  readonly ErrorCode: string;
  readonly Message: string;
}

interface EnvironmentResponse {
  readonly Variables: {[key: string]: any};
  readonly Error: EnvironmentError;
}

interface EventSourceMappingConfiguration {
  readonly UUID: string;
  readonly StartingPosition: string;
  readonly StartingPositionTimestamp: Date;
  readonly BatchSize: number;
  readonly MaximumBatchingWindowInSeconds: number;
  readonly ParallelizationFactor: number;
  readonly EventSourceArn: string;
  readonly FilterCriteria: FilterCriteria;
  readonly FunctionArn: string;
  readonly LastModified: Date;
  readonly LastProcessingResult: string;
  readonly State: string;
  readonly StateTransitionReason: string;
  readonly DestinationConfig: DestinationConfig;
  readonly Topics: [];
  readonly Queues: [];
  readonly SourceAccessConfigurations: [];
  readonly SelfManagedEventSource: SelfManagedEventSource;
  readonly MaximumRecordAgeInSeconds: number;
  readonly BisectBatchOnFunctionError: boolean;
  readonly MaximumRetryAttempts: number;
  readonly TumblingWindowInSeconds: number;
  readonly FunctionResponseTypes: [];
}

interface FileSystemConfig {
  readonly Arn: string;
  readonly LocalMountPath: string;
}

interface Filter {
  readonly Pattern: string;
}

interface FilterCriteria {
  readonly Filters: [];
}

interface FunctionCode {
  readonly ZipFile: unknown;
  readonly S3Bucket: string;
  readonly S3Key: string;
  readonly S3ObjectVersion: string;
  readonly ImageUri: string;
}

interface FunctionCodeLocation {
  readonly RepositoryType: string;
  readonly Location: string;
  readonly ImageUri: string;
  readonly ResolvedImageUri: string;
}

interface FunctionConfiguration {
  readonly FunctionName: string;
  readonly FunctionArn: string;
  readonly Runtime: string;
  readonly Role: string;
  readonly Handler: string;
  readonly CodeSize: number;
  readonly Description: string;
  readonly Timeout: number;
  readonly MemorySize: number;
  readonly LastModified: string;
  readonly CodeSha256: string;
  readonly Version: string;
  readonly VpcConfig: VpcConfigResponse;
  readonly DeadLetterConfig: DeadLetterConfig;
  readonly Environment: EnvironmentResponse;
  readonly KMSKeyArn: string;
  readonly TracingConfig: TracingConfigResponse;
  readonly MasterArn: string;
  readonly RevisionId: string;
  readonly Layers: [];
  readonly State: string;
  readonly StateReason: string;
  readonly StateReasonCode: string;
  readonly LastUpdateStatus: string;
  readonly LastUpdateStatusReason: string;
  readonly LastUpdateStatusReasonCode: string;
  readonly FileSystemConfigs: [];
  readonly PackageType: string;
  readonly ImageConfigResponse: ImageConfigResponse;
  readonly SigningProfileVersionArn: string;
  readonly SigningJobArn: string;
  readonly Architectures: [];
}

interface FunctionEventInvokeConfig {
  readonly LastModified: Date;
  readonly FunctionArn: string;
  readonly MaximumRetryAttempts: number;
  readonly MaximumEventAgeInSeconds: number;
  readonly DestinationConfig: DestinationConfig;
}

interface GetAccountSettingsRequest {
}

interface GetAccountSettingsResponse {
  readonly AccountLimit: AccountLimit;
  readonly AccountUsage: AccountUsage;
}

interface GetAliasRequest {
  readonly FunctionName: string;
  readonly Name: string;
}

interface GetCodeSigningConfigRequest {
  readonly CodeSigningConfigArn: string;
}

interface GetCodeSigningConfigResponse {
  readonly CodeSigningConfig: CodeSigningConfig;
}

interface GetEventSourceMappingRequest {
  readonly UUID: string;
}

interface GetFunctionCodeSigningConfigRequest {
  readonly FunctionName: string;
}

interface GetFunctionCodeSigningConfigResponse {
  readonly CodeSigningConfigArn: string;
  readonly FunctionName: string;
}

interface GetFunctionConcurrencyRequest {
  readonly FunctionName: string;
}

interface GetFunctionConcurrencyResponse {
  readonly ReservedConcurrentExecutions: number;
}

interface GetFunctionConfigurationRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface GetFunctionEventInvokeConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface GetFunctionRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface GetFunctionResponse {
  readonly Configuration: FunctionConfiguration;
  readonly Code: FunctionCodeLocation;
  readonly Tags: {[key: string]: any};
  readonly Concurrency: Concurrency;
}

interface GetLayerVersionByArnRequest {
  readonly Arn: string;
}

interface GetLayerVersionPolicyRequest {
  readonly LayerName: string;
  readonly VersionNumber: number;
}

interface GetLayerVersionPolicyResponse {
  readonly Policy: string;
  readonly RevisionId: string;
}

interface GetLayerVersionRequest {
  readonly LayerName: string;
  readonly VersionNumber: number;
}

interface GetLayerVersionResponse {
  readonly Content: LayerVersionContentOutput;
  readonly LayerArn: string;
  readonly LayerVersionArn: string;
  readonly Description: string;
  readonly CreatedDate: string;
  readonly Version: number;
  readonly CompatibleRuntimes: [];
  readonly LicenseInfo: string;
  readonly CompatibleArchitectures: [];
}

interface GetPolicyRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface GetPolicyResponse {
  readonly Policy: string;
  readonly RevisionId: string;
}

interface GetProvisionedConcurrencyConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
}

interface GetProvisionedConcurrencyConfigResponse {
  readonly RequestedProvisionedConcurrentExecutions: number;
  readonly AvailableProvisionedConcurrentExecutions: number;
  readonly AllocatedProvisionedConcurrentExecutions: number;
  readonly Status: string;
  readonly StatusReason: string;
  readonly LastModified: string;
}

interface ImageConfig {
  readonly EntryPoint: [];
  readonly Command: [];
  readonly WorkingDirectory: string;
}

interface ImageConfigError {
  readonly ErrorCode: string;
  readonly Message: string;
}

interface ImageConfigResponse {
  readonly ImageConfig: ImageConfig;
  readonly Error: ImageConfigError;
}

interface InvalidCodeSignatureException {
  readonly Type: string;
  readonly Message: string;
}

interface InvalidParameterValueException {
  readonly Type: string;
  readonly message: string;
}

interface InvalidRequestContentException {
  readonly Type: string;
  readonly message: string;
}

interface InvalidRuntimeException {
  readonly Type: string;
  readonly Message: string;
}

interface InvalidSecurityGroupIDException {
  readonly Type: string;
  readonly Message: string;
}

interface InvalidSubnetIDException {
  readonly Type: string;
  readonly Message: string;
}

interface InvalidZipFileException {
  readonly Type: string;
  readonly Message: string;
}

interface InvocationRequest {
  readonly FunctionName: string;
  readonly InvocationType: string;
  readonly LogType: string;
  readonly ClientContext: string;
  readonly Payload: unknown;
  readonly Qualifier: string;
}

interface InvocationResponse {
  readonly StatusCode: number;
  readonly FunctionError: string;
  readonly LogResult: string;
  readonly Payload: unknown;
  readonly ExecutedVersion: string;
}

interface InvokeAsyncRequest {
  readonly FunctionName: string;
  readonly InvokeArgs: unknown;
}

interface InvokeAsyncResponse {
  readonly Status: number;
}

interface KMSAccessDeniedException {
  readonly Type: string;
  readonly Message: string;
}

interface KMSDisabledException {
  readonly Type: string;
  readonly Message: string;
}

interface KMSInvalidStateException {
  readonly Type: string;
  readonly Message: string;
}

interface KMSNotFoundException {
  readonly Type: string;
  readonly Message: string;
}

interface Layer {
  readonly Arn: string;
  readonly CodeSize: number;
  readonly SigningProfileVersionArn: string;
  readonly SigningJobArn: string;
}

interface LayerVersionContentInput {
  readonly S3Bucket: string;
  readonly S3Key: string;
  readonly S3ObjectVersion: string;
  readonly ZipFile: unknown;
}

interface LayerVersionContentOutput {
  readonly Location: string;
  readonly CodeSha256: string;
  readonly CodeSize: number;
  readonly SigningProfileVersionArn: string;
  readonly SigningJobArn: string;
}

interface LayerVersionsListItem {
  readonly LayerVersionArn: string;
  readonly Version: number;
  readonly Description: string;
  readonly CreatedDate: string;
  readonly CompatibleRuntimes: [];
  readonly LicenseInfo: string;
  readonly CompatibleArchitectures: [];
}

interface LayersListItem {
  readonly LayerName: string;
  readonly LayerArn: string;
  readonly LatestMatchingVersion: LayerVersionsListItem;
}

interface ListAliasesRequest {
  readonly FunctionName: string;
  readonly FunctionVersion: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListAliasesResponse {
  readonly NextMarker: string;
  readonly Aliases: [];
}

interface ListCodeSigningConfigsRequest {
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListCodeSigningConfigsResponse {
  readonly NextMarker: string;
  readonly CodeSigningConfigs: [];
}

interface ListEventSourceMappingsRequest {
  readonly EventSourceArn: string;
  readonly FunctionName: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListEventSourceMappingsResponse {
  readonly NextMarker: string;
  readonly EventSourceMappings: [];
}

interface ListFunctionEventInvokeConfigsRequest {
  readonly FunctionName: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListFunctionEventInvokeConfigsResponse {
  readonly FunctionEventInvokeConfigs: [];
  readonly NextMarker: string;
}

interface ListFunctionsByCodeSigningConfigRequest {
  readonly CodeSigningConfigArn: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListFunctionsByCodeSigningConfigResponse {
  readonly NextMarker: string;
  readonly FunctionArns: [];
}

interface ListFunctionsRequest {
  readonly MasterRegion: string;
  readonly FunctionVersion: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListFunctionsResponse {
  readonly NextMarker: string;
  readonly Functions: [];
}

interface ListLayerVersionsRequest {
  readonly CompatibleRuntime: string;
  readonly LayerName: string;
  readonly Marker: string;
  readonly MaxItems: number;
  readonly CompatibleArchitecture: string;
}

interface ListLayerVersionsResponse {
  readonly NextMarker: string;
  readonly LayerVersions: [];
}

interface ListLayersRequest {
  readonly CompatibleRuntime: string;
  readonly Marker: string;
  readonly MaxItems: number;
  readonly CompatibleArchitecture: string;
}

interface ListLayersResponse {
  readonly NextMarker: string;
  readonly Layers: [];
}

interface ListProvisionedConcurrencyConfigsRequest {
  readonly FunctionName: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListProvisionedConcurrencyConfigsResponse {
  readonly ProvisionedConcurrencyConfigs: [];
  readonly NextMarker: string;
}

interface ListTagsRequest {
  readonly Resource: string;
}

interface ListTagsResponse {
  readonly Tags: {[key: string]: any};
}

interface ListVersionsByFunctionRequest {
  readonly FunctionName: string;
  readonly Marker: string;
  readonly MaxItems: number;
}

interface ListVersionsByFunctionResponse {
  readonly NextMarker: string;
  readonly Versions: [];
}

interface OnFailure {
  readonly Destination: string;
}

interface OnSuccess {
  readonly Destination: string;
}

interface PolicyLengthExceededException {
  readonly Type: string;
  readonly message: string;
}

interface PreconditionFailedException {
  readonly Type: string;
  readonly message: string;
}

interface ProvisionedConcurrencyConfigListItem {
  readonly FunctionArn: string;
  readonly RequestedProvisionedConcurrentExecutions: number;
  readonly AvailableProvisionedConcurrentExecutions: number;
  readonly AllocatedProvisionedConcurrentExecutions: number;
  readonly Status: string;
  readonly StatusReason: string;
  readonly LastModified: string;
}

interface ProvisionedConcurrencyConfigNotFoundException {
  readonly Type: string;
  readonly message: string;
}

interface PublishLayerVersionRequest {
  readonly LayerName: string;
  readonly Description: string;
  readonly Content: LayerVersionContentInput;
  readonly CompatibleRuntimes: [];
  readonly LicenseInfo: string;
  readonly CompatibleArchitectures: [];
}

interface PublishLayerVersionResponse {
  readonly Content: LayerVersionContentOutput;
  readonly LayerArn: string;
  readonly LayerVersionArn: string;
  readonly Description: string;
  readonly CreatedDate: string;
  readonly Version: number;
  readonly CompatibleRuntimes: [];
  readonly LicenseInfo: string;
  readonly CompatibleArchitectures: [];
}

interface PublishVersionRequest {
  readonly FunctionName: string;
  readonly CodeSha256: string;
  readonly Description: string;
  readonly RevisionId: string;
}

interface PutFunctionCodeSigningConfigRequest {
  readonly CodeSigningConfigArn: string;
  readonly FunctionName: string;
}

interface PutFunctionCodeSigningConfigResponse {
  readonly CodeSigningConfigArn: string;
  readonly FunctionName: string;
}

interface PutFunctionConcurrencyRequest {
  readonly FunctionName: string;
  readonly ReservedConcurrentExecutions: number;
}

interface PutFunctionEventInvokeConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
  readonly MaximumRetryAttempts: number;
  readonly MaximumEventAgeInSeconds: number;
  readonly DestinationConfig: DestinationConfig;
}

interface PutProvisionedConcurrencyConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
  readonly ProvisionedConcurrentExecutions: number;
}

interface PutProvisionedConcurrencyConfigResponse {
  readonly RequestedProvisionedConcurrentExecutions: number;
  readonly AvailableProvisionedConcurrentExecutions: number;
  readonly AllocatedProvisionedConcurrentExecutions: number;
  readonly Status: string;
  readonly StatusReason: string;
  readonly LastModified: string;
}

interface RemoveLayerVersionPermissionRequest {
  readonly LayerName: string;
  readonly VersionNumber: number;
  readonly StatementId: string;
  readonly RevisionId: string;
}

interface RemovePermissionRequest {
  readonly FunctionName: string;
  readonly StatementId: string;
  readonly Qualifier: string;
  readonly RevisionId: string;
}

interface RequestTooLargeException {
  readonly Type: string;
  readonly message: string;
}

interface ResourceConflictException {
  readonly Type: string;
  readonly message: string;
}

interface ResourceInUseException {
  readonly Type: string;
  readonly Message: string;
}

interface ResourceNotFoundException {
  readonly Type: string;
  readonly Message: string;
}

interface ResourceNotReadyException {
  readonly Type: string;
  readonly message: string;
}

interface SelfManagedEventSource {
  readonly Endpoints: {[key: string]: any};
}

interface ServiceException {
  readonly Type: string;
  readonly Message: string;
}

interface SourceAccessConfiguration {
  readonly Type: string;
  readonly URI: string;
}

interface SubnetIPAddressLimitReachedException {
  readonly Type: string;
  readonly Message: string;
}

interface TagResourceRequest {
  readonly Resource: string;
  readonly Tags: {[key: string]: any};
}

interface TooManyRequestsException {
  readonly retryAfterSeconds: string;
  readonly Type: string;
  readonly message: string;
  readonly Reason: string;
}

interface TracingConfig {
  readonly Mode: string;
}

interface TracingConfigResponse {
  readonly Mode: string;
}

interface UnsupportedMediaTypeException {
  readonly Type: string;
  readonly message: string;
}

interface UntagResourceRequest {
  readonly Resource: string;
  readonly TagKeys: [];
}

interface UpdateAliasRequest {
  readonly FunctionName: string;
  readonly Name: string;
  readonly FunctionVersion: string;
  readonly Description: string;
  readonly RoutingConfig: AliasRoutingConfiguration;
  readonly RevisionId: string;
}

interface UpdateCodeSigningConfigRequest {
  readonly CodeSigningConfigArn: string;
  readonly Description: string;
  readonly AllowedPublishers: AllowedPublishers;
  readonly CodeSigningPolicies: CodeSigningPolicies;
}

interface UpdateCodeSigningConfigResponse {
  readonly CodeSigningConfig: CodeSigningConfig;
}

interface UpdateEventSourceMappingRequest {
  readonly UUID: string;
  readonly FunctionName: string;
  readonly Enabled: boolean;
  readonly BatchSize: number;
  readonly FilterCriteria: FilterCriteria;
  readonly MaximumBatchingWindowInSeconds: number;
  readonly DestinationConfig: DestinationConfig;
  readonly MaximumRecordAgeInSeconds: number;
  readonly BisectBatchOnFunctionError: boolean;
  readonly MaximumRetryAttempts: number;
  readonly ParallelizationFactor: number;
  readonly SourceAccessConfigurations: [];
  readonly TumblingWindowInSeconds: number;
  readonly FunctionResponseTypes: [];
}

interface UpdateFunctionCodeRequest {
  readonly FunctionName: string;
  readonly ZipFile: unknown;
  readonly S3Bucket: string;
  readonly S3Key: string;
  readonly S3ObjectVersion: string;
  readonly ImageUri: string;
  readonly Publish: boolean;
  readonly DryRun: boolean;
  readonly RevisionId: string;
  readonly Architectures: [];
}

interface UpdateFunctionConfigurationRequest {
  readonly FunctionName: string;
  readonly Role: string;
  readonly Handler: string;
  readonly Description: string;
  readonly Timeout: number;
  readonly MemorySize: number;
  readonly VpcConfig: VpcConfig;
  readonly Environment: Environment;
  readonly Runtime: string;
  readonly DeadLetterConfig: DeadLetterConfig;
  readonly KMSKeyArn: string;
  readonly TracingConfig: TracingConfig;
  readonly RevisionId: string;
  readonly Layers: [];
  readonly FileSystemConfigs: [];
  readonly ImageConfig: ImageConfig;
}

interface UpdateFunctionEventInvokeConfigRequest {
  readonly FunctionName: string;
  readonly Qualifier: string;
  readonly MaximumRetryAttempts: number;
  readonly MaximumEventAgeInSeconds: number;
  readonly DestinationConfig: DestinationConfig;
}

interface VpcConfig {
  readonly SubnetIds: [];
  readonly SecurityGroupIds: [];
}

interface VpcConfigResponse {
  readonly SubnetIds: [];
  readonly SecurityGroupIds: [];
  readonly VpcId: string;
}

