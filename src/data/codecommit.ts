/**
 * STOP. This file is autogenerated. DO NOT EDIT by hand
 */
export interface AssociateApprovalRuleTemplateWithRepository {
  readonly approvalRuleTemplateName: string;
  readonly repositoryName: string;
}
export interface BatchAssociateApprovalRuleTemplateWithRepositories {
  readonly approvalRuleTemplateName: string;
  readonly repositoryNames: [];
}
export interface BatchDescribeMergeConflicts {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly maxMergeHunks: number;
  readonly maxConflictFiles: number;
  readonly filePaths: [];
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}
export interface BatchDisassociateApprovalRuleTemplateFromRepositories {
  readonly approvalRuleTemplateName: string;
  readonly repositoryNames: [];
}
export interface BatchGetCommits {
  readonly commitIds: [];
  readonly repositoryName: string;
}
export interface BatchGetRepositories {
  readonly repositoryNames: [];
}
export interface CreateApprovalRuleTemplate {
  readonly approvalRuleTemplateName: string;
  readonly approvalRuleTemplateContent: string;
  readonly approvalRuleTemplateDescription: string;
}
export interface CreateBranch {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly commitId: string;
}
export interface CreateCommit {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly parentCommitId: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly putFiles: [];
  readonly deleteFiles: [];
  readonly setFileModes: [];
}
export interface CreatePullRequest {
  readonly title: string;
  readonly description: string;
  readonly targets: [];
  readonly clientRequestToken: string;
}
export interface CreatePullRequestApprovalRule {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
  readonly approvalRuleContent: string;
}
export interface CreateRepository {
  readonly repositoryName: string;
  readonly repositoryDescription: string;
  readonly tags: {[key: string]: any};
}
export interface CreateUnreferencedMergeCommit {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly mergeOption: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}
export interface DeleteApprovalRuleTemplate {
  readonly approvalRuleTemplateName: string;
}
export interface DeleteBranch {
  readonly repositoryName: string;
  readonly branchName: string;
}
export interface DeleteCommentContent {
  readonly commentId: string;
}
export interface DeleteFile {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly filePath: string;
  readonly parentCommitId: string;
  readonly keepEmptyFolders: boolean;
  readonly commitMessage: string;
  readonly name: string;
  readonly email: string;
}
export interface DeletePullRequestApprovalRule {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
}
export interface DeleteRepository {
  readonly repositoryName: string;
}
export interface DescribeMergeConflicts {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly maxMergeHunks: number;
  readonly filePath: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}
export interface DescribePullRequestEvents {
  readonly pullRequestId: string;
  readonly pullRequestEventType: string;
  readonly actorArn: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface DisassociateApprovalRuleTemplateFromRepository {
  readonly approvalRuleTemplateName: string;
  readonly repositoryName: string;
}
export interface EvaluatePullRequestApprovalRules {
  readonly pullRequestId: string;
  readonly revisionId: string;
}
export interface GetApprovalRuleTemplate {
  readonly approvalRuleTemplateName: string;
}
export interface GetBlob {
  readonly repositoryName: string;
  readonly blobId: string;
}
export interface GetBranch {
  readonly repositoryName: string;
  readonly branchName: string;
}
export interface GetComment {
  readonly commentId: string;
}
export interface GetCommentReactions {
  readonly commentId: string;
  readonly reactionUserArn: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface GetCommentsForComparedCommit {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface GetCommentsForPullRequest {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface GetCommit {
  readonly repositoryName: string;
  readonly commitId: string;
}
export interface GetDifferences {
  readonly repositoryName: string;
  readonly beforeCommitSpecifier: string;
  readonly afterCommitSpecifier: string;
  readonly beforePath: string;
  readonly afterPath: string;
  readonly MaxResults: number;
  readonly NextToken: string;
}
export interface GetFile {
  readonly repositoryName: string;
  readonly commitSpecifier: string;
  readonly filePath: string;
}
export interface GetFolder {
  readonly repositoryName: string;
  readonly commitSpecifier: string;
  readonly folderPath: string;
}
export interface GetMergeCommit {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
}
export interface GetMergeConflicts {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly conflictDetailLevel: string;
  readonly maxConflictFiles: number;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}
export interface GetMergeOptions {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
}
export interface GetPullRequest {
  readonly pullRequestId: string;
}
export interface GetPullRequestApprovalStates {
  readonly pullRequestId: string;
  readonly revisionId: string;
}
export interface GetPullRequestOverrideState {
  readonly pullRequestId: string;
  readonly revisionId: string;
}
export interface GetRepository {
  readonly repositoryName: string;
}
export interface GetRepositoryTriggers {
  readonly repositoryName: string;
}
export interface ListApprovalRuleTemplates {
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface ListAssociatedApprovalRuleTemplatesForRepository {
  readonly repositoryName: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface ListBranches {
  readonly repositoryName: string;
  readonly nextToken: string;
}
export interface ListPullRequests {
  readonly repositoryName: string;
  readonly authorArn: string;
  readonly pullRequestStatus: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface ListRepositories {
  readonly nextToken: string;
  readonly sortBy: string;
  readonly order: string;
}
export interface ListRepositoriesForApprovalRuleTemplate {
  readonly approvalRuleTemplateName: string;
  readonly nextToken: string;
  readonly maxResults: number;
}
export interface ListTagsForResource {
  readonly resourceArn: string;
  readonly nextToken: string;
}
export interface MergeBranchesByFastForward {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
}
export interface MergeBranchesBySquash {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}
export interface MergeBranchesByThreeWay {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}
export interface MergePullRequestByFastForward {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
}
export interface MergePullRequestBySquash {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly commitMessage: string;
  readonly authorName: string;
  readonly email: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}
export interface MergePullRequestByThreeWay {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly commitMessage: string;
  readonly authorName: string;
  readonly email: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}
export interface OverridePullRequestApprovalRules {
  readonly pullRequestId: string;
  readonly revisionId: string;
  readonly overrideStatus: string;
}
export interface PostCommentForComparedCommit {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly location: Location;
  readonly content: string;
  readonly clientRequestToken: string;
}
export interface PostCommentForPullRequest {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly location: Location;
  readonly content: string;
  readonly clientRequestToken: string;
}
export interface PostCommentReply {
  readonly inReplyTo: string;
  readonly clientRequestToken: string;
  readonly content: string;
}
export interface PutCommentReaction {
  readonly commentId: string;
  readonly reactionValue: string;
}
export interface PutFile {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly fileContent: unknown;
  readonly filePath: string;
  readonly fileMode: string;
  readonly parentCommitId: string;
  readonly commitMessage: string;
  readonly name: string;
  readonly email: string;
}
export interface PutRepositoryTriggers {
  readonly repositoryName: string;
  readonly triggers: [];
}
export interface TagResource {
  readonly resourceArn: string;
  readonly tags: {[key: string]: any};
}
export interface TestRepositoryTriggers {
  readonly repositoryName: string;
  readonly triggers: [];
}
export interface UntagResource {
  readonly resourceArn: string;
  readonly tagKeys: [];
}
export interface UpdateApprovalRuleTemplateContent {
  readonly approvalRuleTemplateName: string;
  readonly newRuleContent: string;
  readonly existingRuleContentSha256: string;
}
export interface UpdateApprovalRuleTemplateDescription {
  readonly approvalRuleTemplateName: string;
  readonly approvalRuleTemplateDescription: string;
}
export interface UpdateApprovalRuleTemplateName {
  readonly oldApprovalRuleTemplateName: string;
  readonly newApprovalRuleTemplateName: string;
}
export interface UpdateComment {
  readonly commentId: string;
  readonly content: string;
}
export interface UpdateDefaultBranch {
  readonly repositoryName: string;
  readonly defaultBranchName: string;
}
export interface UpdatePullRequestApprovalRuleContent {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
  readonly existingRuleContentSha256: string;
  readonly newRuleContent: string;
}
export interface UpdatePullRequestApprovalState {
  readonly pullRequestId: string;
  readonly revisionId: string;
  readonly approvalState: string;
}
export interface UpdatePullRequestDescription {
  readonly pullRequestId: string;
  readonly description: string;
}
export interface UpdatePullRequestStatus {
  readonly pullRequestId: string;
  readonly pullRequestStatus: string;
}
export interface UpdatePullRequestTitle {
  readonly pullRequestId: string;
  readonly title: string;
}
export interface UpdateRepositoryDescription {
  readonly repositoryName: string;
  readonly repositoryDescription: string;
}
export interface UpdateRepositoryName {
  readonly oldName: string;
  readonly newName: string;
}



interface ActorDoesNotExistException {
}

interface Approval {
  readonly userArn: string;
  readonly approvalState: string;
}

interface ApprovalRule {
  readonly approvalRuleId: string;
  readonly approvalRuleName: string;
  readonly approvalRuleContent: string;
  readonly ruleContentSha256: string;
  readonly lastModifiedDate: Date;
  readonly creationDate: Date;
  readonly lastModifiedUser: string;
  readonly originApprovalRuleTemplate: OriginApprovalRuleTemplate;
}

interface ApprovalRuleContentRequiredException {
}

interface ApprovalRuleDoesNotExistException {
}

interface ApprovalRuleEventMetadata {
  readonly approvalRuleName: string;
  readonly approvalRuleId: string;
  readonly approvalRuleContent: string;
}

interface ApprovalRuleNameAlreadyExistsException {
}

interface ApprovalRuleNameRequiredException {
}

interface ApprovalRuleOverriddenEventMetadata {
  readonly revisionId: string;
  readonly overrideStatus: string;
}

interface ApprovalRuleTemplate {
  readonly approvalRuleTemplateId: string;
  readonly approvalRuleTemplateName: string;
  readonly approvalRuleTemplateDescription: string;
  readonly approvalRuleTemplateContent: string;
  readonly ruleContentSha256: string;
  readonly lastModifiedDate: Date;
  readonly creationDate: Date;
  readonly lastModifiedUser: string;
}

interface ApprovalRuleTemplateContentRequiredException {
}

interface ApprovalRuleTemplateDoesNotExistException {
}

interface ApprovalRuleTemplateInUseException {
}

interface ApprovalRuleTemplateNameAlreadyExistsException {
}

interface ApprovalRuleTemplateNameRequiredException {
}

interface ApprovalStateChangedEventMetadata {
  readonly revisionId: string;
  readonly approvalStatus: string;
}

interface ApprovalStateRequiredException {
}

interface AssociateApprovalRuleTemplateWithRepositoryInput {
  readonly approvalRuleTemplateName: string;
  readonly repositoryName: string;
}

interface AuthorDoesNotExistException {
}

interface BatchAssociateApprovalRuleTemplateWithRepositoriesError {
  readonly repositoryName: string;
  readonly errorCode: string;
  readonly errorMessage: string;
}

interface BatchAssociateApprovalRuleTemplateWithRepositoriesInput {
  readonly approvalRuleTemplateName: string;
  readonly repositoryNames: [];
}

interface BatchAssociateApprovalRuleTemplateWithRepositoriesOutput {
  readonly associatedRepositoryNames: [];
  readonly errors: [];
}

interface BatchDescribeMergeConflictsError {
  readonly filePath: string;
  readonly exceptionName: string;
  readonly message: string;
}

interface BatchDescribeMergeConflictsInput {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly maxMergeHunks: number;
  readonly maxConflictFiles: number;
  readonly filePaths: [];
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}

interface BatchDescribeMergeConflictsOutput {
  readonly conflicts: [];
  readonly nextToken: string;
  readonly errors: [];
  readonly destinationCommitId: string;
  readonly sourceCommitId: string;
  readonly baseCommitId: string;
}

interface BatchDisassociateApprovalRuleTemplateFromRepositoriesError {
  readonly repositoryName: string;
  readonly errorCode: string;
  readonly errorMessage: string;
}

interface BatchDisassociateApprovalRuleTemplateFromRepositoriesInput {
  readonly approvalRuleTemplateName: string;
  readonly repositoryNames: [];
}

interface BatchDisassociateApprovalRuleTemplateFromRepositoriesOutput {
  readonly disassociatedRepositoryNames: [];
  readonly errors: [];
}

interface BatchGetCommitsError {
  readonly commitId: string;
  readonly errorCode: string;
  readonly errorMessage: string;
}

interface BatchGetCommitsInput {
  readonly commitIds: [];
  readonly repositoryName: string;
}

interface BatchGetCommitsOutput {
  readonly commits: [];
  readonly errors: [];
}

interface BatchGetRepositoriesInput {
  readonly repositoryNames: [];
}

interface BatchGetRepositoriesOutput {
  readonly repositories: [];
  readonly repositoriesNotFound: [];
}

interface BeforeCommitIdAndAfterCommitIdAreSameException {
}

interface BlobIdDoesNotExistException {
}

interface BlobIdRequiredException {
}

interface BlobMetadata {
  readonly blobId: string;
  readonly path: string;
  readonly mode: string;
}

interface BranchDoesNotExistException {
}

interface BranchInfo {
  readonly branchName: string;
  readonly commitId: string;
}

interface BranchNameExistsException {
}

interface BranchNameIsTagNameException {
}

interface BranchNameRequiredException {
}

interface CannotDeleteApprovalRuleFromTemplateException {
}

interface CannotModifyApprovalRuleFromTemplateException {
}

interface ClientRequestTokenRequiredException {
}

interface Comment {
  readonly commentId: string;
  readonly content: string;
  readonly inReplyTo: string;
  readonly creationDate: Date;
  readonly lastModifiedDate: Date;
  readonly authorArn: string;
  readonly deleted: boolean;
  readonly clientRequestToken: string;
  readonly callerReactions: [];
  readonly reactionCounts: {[key: string]: any};
}

interface CommentContentRequiredException {
}

interface CommentContentSizeLimitExceededException {
}

interface CommentDeletedException {
}

interface CommentDoesNotExistException {
}

interface CommentIdRequiredException {
}

interface CommentNotCreatedByCallerException {
}

interface CommentsForComparedCommit {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly beforeBlobId: string;
  readonly afterBlobId: string;
  readonly location: Location;
  readonly comments: [];
}

interface CommentsForPullRequest {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly beforeBlobId: string;
  readonly afterBlobId: string;
  readonly location: Location;
  readonly comments: [];
}

interface Commit {
  readonly commitId: string;
  readonly treeId: string;
  readonly parents: [];
  readonly message: string;
  readonly author: UserInfo;
  readonly committer: UserInfo;
  readonly additionalData: string;
}

interface CommitDoesNotExistException {
}

interface CommitIdDoesNotExistException {
}

interface CommitIdRequiredException {
}

interface CommitIdsLimitExceededException {
}

interface CommitIdsListRequiredException {
}

interface CommitMessageLengthExceededException {
}

interface CommitRequiredException {
}

interface ConcurrentReferenceUpdateException {
}

interface Conflict {
  readonly conflictMetadata: ConflictMetadata;
  readonly mergeHunks: [];
}

interface ConflictMetadata {
  readonly filePath: string;
  readonly fileSizes: FileSizes;
  readonly fileModes: FileModes;
  readonly objectTypes: ObjectTypes;
  readonly numberOfConflicts: number;
  readonly isBinaryFile: IsBinaryFile;
  readonly contentConflict: boolean;
  readonly fileModeConflict: boolean;
  readonly objectTypeConflict: boolean;
  readonly mergeOperations: MergeOperations;
}

interface ConflictResolution {
  readonly replaceContents: [];
  readonly deleteFiles: [];
  readonly setFileModes: [];
}

interface CreateApprovalRuleTemplateInput {
  readonly approvalRuleTemplateName: string;
  readonly approvalRuleTemplateContent: string;
  readonly approvalRuleTemplateDescription: string;
}

interface CreateApprovalRuleTemplateOutput {
  readonly approvalRuleTemplate: ApprovalRuleTemplate;
}

interface CreateBranchInput {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly commitId: string;
}

interface CreateCommitInput {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly parentCommitId: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly putFiles: [];
  readonly deleteFiles: [];
  readonly setFileModes: [];
}

interface CreateCommitOutput {
  readonly commitId: string;
  readonly treeId: string;
  readonly filesAdded: [];
  readonly filesUpdated: [];
  readonly filesDeleted: [];
}

interface CreatePullRequestApprovalRuleInput {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
  readonly approvalRuleContent: string;
}

interface CreatePullRequestApprovalRuleOutput {
  readonly approvalRule: ApprovalRule;
}

interface CreatePullRequestInput {
  readonly title: string;
  readonly description: string;
  readonly targets: [];
  readonly clientRequestToken: string;
}

interface CreatePullRequestOutput {
  readonly pullRequest: PullRequest;
}

interface CreateRepositoryInput {
  readonly repositoryName: string;
  readonly repositoryDescription: string;
  readonly tags: {[key: string]: any};
}

interface CreateRepositoryOutput {
  readonly repositoryMetadata: RepositoryMetadata;
}

interface CreateUnreferencedMergeCommitInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly mergeOption: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}

interface CreateUnreferencedMergeCommitOutput {
  readonly commitId: string;
  readonly treeId: string;
}

interface DefaultBranchCannotBeDeletedException {
}

interface DeleteApprovalRuleTemplateInput {
  readonly approvalRuleTemplateName: string;
}

interface DeleteApprovalRuleTemplateOutput {
  readonly approvalRuleTemplateId: string;
}

interface DeleteBranchInput {
  readonly repositoryName: string;
  readonly branchName: string;
}

interface DeleteBranchOutput {
  readonly deletedBranch: BranchInfo;
}

interface DeleteCommentContentInput {
  readonly commentId: string;
}

interface DeleteCommentContentOutput {
  readonly comment: Comment;
}

interface DeleteFileEntry {
  readonly filePath: string;
}

interface DeleteFileInput {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly filePath: string;
  readonly parentCommitId: string;
  readonly keepEmptyFolders: boolean;
  readonly commitMessage: string;
  readonly name: string;
  readonly email: string;
}

interface DeleteFileOutput {
  readonly commitId: string;
  readonly blobId: string;
  readonly treeId: string;
  readonly filePath: string;
}

interface DeletePullRequestApprovalRuleInput {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
}

interface DeletePullRequestApprovalRuleOutput {
  readonly approvalRuleId: string;
}

interface DeleteRepositoryInput {
  readonly repositoryName: string;
}

interface DeleteRepositoryOutput {
  readonly repositoryId: string;
}

interface DescribeMergeConflictsInput {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly maxMergeHunks: number;
  readonly filePath: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}

interface DescribeMergeConflictsOutput {
  readonly conflictMetadata: ConflictMetadata;
  readonly mergeHunks: [];
  readonly nextToken: string;
  readonly destinationCommitId: string;
  readonly sourceCommitId: string;
  readonly baseCommitId: string;
}

interface DescribePullRequestEventsInput {
  readonly pullRequestId: string;
  readonly pullRequestEventType: string;
  readonly actorArn: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface DescribePullRequestEventsOutput {
  readonly pullRequestEvents: [];
  readonly nextToken: string;
}

interface Difference {
  readonly beforeBlob: BlobMetadata;
  readonly afterBlob: BlobMetadata;
  readonly changeType: string;
}

interface DirectoryNameConflictsWithFileNameException {
}

interface DisassociateApprovalRuleTemplateFromRepositoryInput {
  readonly approvalRuleTemplateName: string;
  readonly repositoryName: string;
}

interface EncryptionIntegrityChecksFailedException {
}

interface EncryptionKeyAccessDeniedException {
}

interface EncryptionKeyDisabledException {
}

interface EncryptionKeyNotFoundException {
}

interface EncryptionKeyUnavailableException {
}

interface EvaluatePullRequestApprovalRulesInput {
  readonly pullRequestId: string;
  readonly revisionId: string;
}

interface EvaluatePullRequestApprovalRulesOutput {
  readonly evaluation: Evaluation;
}

interface Evaluation {
  readonly approved: boolean;
  readonly overridden: boolean;
  readonly approvalRulesSatisfied: [];
  readonly approvalRulesNotSatisfied: [];
}

interface File {
  readonly blobId: string;
  readonly absolutePath: string;
  readonly relativePath: string;
  readonly fileMode: string;
}

interface FileContentAndSourceFileSpecifiedException {
}

interface FileContentRequiredException {
}

interface FileContentSizeLimitExceededException {
}

interface FileDoesNotExistException {
}

interface FileEntryRequiredException {
}

interface FileMetadata {
  readonly absolutePath: string;
  readonly blobId: string;
  readonly fileMode: string;
}

interface FileModeRequiredException {
}

interface FileModes {
  readonly source: string;
  readonly destination: string;
  readonly base: string;
}

interface FileNameConflictsWithDirectoryNameException {
}

interface FilePathConflictsWithSubmodulePathException {
}

interface FileSizes {
  readonly source: number;
  readonly destination: number;
  readonly base: number;
}

interface FileTooLargeException {
}

interface Folder {
  readonly treeId: string;
  readonly absolutePath: string;
  readonly relativePath: string;
}

interface FolderContentSizeLimitExceededException {
}

interface FolderDoesNotExistException {
}

interface GetApprovalRuleTemplateInput {
  readonly approvalRuleTemplateName: string;
}

interface GetApprovalRuleTemplateOutput {
  readonly approvalRuleTemplate: ApprovalRuleTemplate;
}

interface GetBlobInput {
  readonly repositoryName: string;
  readonly blobId: string;
}

interface GetBlobOutput {
  readonly content: unknown;
}

interface GetBranchInput {
  readonly repositoryName: string;
  readonly branchName: string;
}

interface GetBranchOutput {
  readonly branch: BranchInfo;
}

interface GetCommentInput {
  readonly commentId: string;
}

interface GetCommentOutput {
  readonly comment: Comment;
}

interface GetCommentReactionsInput {
  readonly commentId: string;
  readonly reactionUserArn: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface GetCommentReactionsOutput {
  readonly reactionsForComment: [];
  readonly nextToken: string;
}

interface GetCommentsForComparedCommitInput {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface GetCommentsForComparedCommitOutput {
  readonly commentsForComparedCommitData: [];
  readonly nextToken: string;
}

interface GetCommentsForPullRequestInput {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface GetCommentsForPullRequestOutput {
  readonly commentsForPullRequestData: [];
  readonly nextToken: string;
}

interface GetCommitInput {
  readonly repositoryName: string;
  readonly commitId: string;
}

interface GetCommitOutput {
  readonly commit: Commit;
}

interface GetDifferencesInput {
  readonly repositoryName: string;
  readonly beforeCommitSpecifier: string;
  readonly afterCommitSpecifier: string;
  readonly beforePath: string;
  readonly afterPath: string;
  readonly MaxResults: number;
  readonly NextToken: string;
}

interface GetDifferencesOutput {
  readonly differences: [];
  readonly NextToken: string;
}

interface GetFileInput {
  readonly repositoryName: string;
  readonly commitSpecifier: string;
  readonly filePath: string;
}

interface GetFileOutput {
  readonly commitId: string;
  readonly blobId: string;
  readonly filePath: string;
  readonly fileMode: string;
  readonly fileSize: number;
  readonly fileContent: unknown;
}

interface GetFolderInput {
  readonly repositoryName: string;
  readonly commitSpecifier: string;
  readonly folderPath: string;
}

interface GetFolderOutput {
  readonly commitId: string;
  readonly folderPath: string;
  readonly treeId: string;
  readonly subFolders: [];
  readonly files: [];
  readonly symbolicLinks: [];
  readonly subModules: [];
}

interface GetMergeCommitInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
}

interface GetMergeCommitOutput {
  readonly sourceCommitId: string;
  readonly destinationCommitId: string;
  readonly baseCommitId: string;
  readonly mergedCommitId: string;
}

interface GetMergeConflictsInput {
  readonly repositoryName: string;
  readonly destinationCommitSpecifier: string;
  readonly sourceCommitSpecifier: string;
  readonly mergeOption: string;
  readonly conflictDetailLevel: string;
  readonly maxConflictFiles: number;
  readonly conflictResolutionStrategy: string;
  readonly nextToken: string;
}

interface GetMergeConflictsOutput {
  readonly mergeable: boolean;
  readonly destinationCommitId: string;
  readonly sourceCommitId: string;
  readonly baseCommitId: string;
  readonly conflictMetadataList: [];
  readonly nextToken: string;
}

interface GetMergeOptionsInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
}

interface GetMergeOptionsOutput {
  readonly mergeOptions: [];
  readonly sourceCommitId: string;
  readonly destinationCommitId: string;
  readonly baseCommitId: string;
}

interface GetPullRequestApprovalStatesInput {
  readonly pullRequestId: string;
  readonly revisionId: string;
}

interface GetPullRequestApprovalStatesOutput {
  readonly approvals: [];
}

interface GetPullRequestInput {
  readonly pullRequestId: string;
}

interface GetPullRequestOutput {
  readonly pullRequest: PullRequest;
}

interface GetPullRequestOverrideStateInput {
  readonly pullRequestId: string;
  readonly revisionId: string;
}

interface GetPullRequestOverrideStateOutput {
  readonly overridden: boolean;
  readonly overrider: string;
}

interface GetRepositoryInput {
  readonly repositoryName: string;
}

interface GetRepositoryOutput {
  readonly repositoryMetadata: RepositoryMetadata;
}

interface GetRepositoryTriggersInput {
  readonly repositoryName: string;
}

interface GetRepositoryTriggersOutput {
  readonly configurationId: string;
  readonly triggers: [];
}

interface IdempotencyParameterMismatchException {
}

interface InvalidActorArnException {
}

interface InvalidApprovalRuleContentException {
}

interface InvalidApprovalRuleNameException {
}

interface InvalidApprovalRuleTemplateContentException {
}

interface InvalidApprovalRuleTemplateDescriptionException {
}

interface InvalidApprovalRuleTemplateNameException {
}

interface InvalidApprovalStateException {
}

interface InvalidAuthorArnException {
}

interface InvalidBlobIdException {
}

interface InvalidBranchNameException {
}

interface InvalidClientRequestTokenException {
}

interface InvalidCommentIdException {
}

interface InvalidCommitException {
}

interface InvalidCommitIdException {
}

interface InvalidConflictDetailLevelException {
}

interface InvalidConflictResolutionException {
}

interface InvalidConflictResolutionStrategyException {
}

interface InvalidContinuationTokenException {
}

interface InvalidDeletionParameterException {
}

interface InvalidDescriptionException {
}

interface InvalidDestinationCommitSpecifierException {
}

interface InvalidEmailException {
}

interface InvalidFileLocationException {
}

interface InvalidFileModeException {
}

interface InvalidFilePositionException {
}

interface InvalidMaxConflictFilesException {
}

interface InvalidMaxMergeHunksException {
}

interface InvalidMaxResultsException {
}

interface InvalidMergeOptionException {
}

interface InvalidOrderException {
}

interface InvalidOverrideStatusException {
}

interface InvalidParentCommitIdException {
}

interface InvalidPathException {
}

interface InvalidPullRequestEventTypeException {
}

interface InvalidPullRequestIdException {
}

interface InvalidPullRequestStatusException {
}

interface InvalidPullRequestStatusUpdateException {
}

interface InvalidReactionUserArnException {
}

interface InvalidReactionValueException {
}

interface InvalidReferenceNameException {
}

interface InvalidRelativeFileVersionEnumException {
}

interface InvalidReplacementContentException {
}

interface InvalidReplacementTypeException {
}

interface InvalidRepositoryDescriptionException {
}

interface InvalidRepositoryNameException {
}

interface InvalidRepositoryTriggerBranchNameException {
}

interface InvalidRepositoryTriggerCustomDataException {
}

interface InvalidRepositoryTriggerDestinationArnException {
}

interface InvalidRepositoryTriggerEventsException {
}

interface InvalidRepositoryTriggerNameException {
}

interface InvalidRepositoryTriggerRegionException {
}

interface InvalidResourceArnException {
}

interface InvalidRevisionIdException {
}

interface InvalidRuleContentSha256Exception {
}

interface InvalidSortByException {
}

interface InvalidSourceCommitSpecifierException {
}

interface InvalidSystemTagUsageException {
}

interface InvalidTagKeysListException {
}

interface InvalidTagsMapException {
}

interface InvalidTargetBranchException {
}

interface InvalidTargetException {
}

interface InvalidTargetsException {
}

interface InvalidTitleException {
}

interface IsBinaryFile {
  readonly source: boolean;
  readonly destination: boolean;
  readonly base: boolean;
}

interface ListApprovalRuleTemplatesInput {
  readonly nextToken: string;
  readonly maxResults: number;
}

interface ListApprovalRuleTemplatesOutput {
  readonly approvalRuleTemplateNames: [];
  readonly nextToken: string;
}

interface ListAssociatedApprovalRuleTemplatesForRepositoryInput {
  readonly repositoryName: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface ListAssociatedApprovalRuleTemplatesForRepositoryOutput {
  readonly approvalRuleTemplateNames: [];
  readonly nextToken: string;
}

interface ListBranchesInput {
  readonly repositoryName: string;
  readonly nextToken: string;
}

interface ListBranchesOutput {
  readonly branches: [];
  readonly nextToken: string;
}

interface ListPullRequestsInput {
  readonly repositoryName: string;
  readonly authorArn: string;
  readonly pullRequestStatus: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface ListPullRequestsOutput {
  readonly pullRequestIds: [];
  readonly nextToken: string;
}

interface ListRepositoriesForApprovalRuleTemplateInput {
  readonly approvalRuleTemplateName: string;
  readonly nextToken: string;
  readonly maxResults: number;
}

interface ListRepositoriesForApprovalRuleTemplateOutput {
  readonly repositoryNames: [];
  readonly nextToken: string;
}

interface ListRepositoriesInput {
  readonly nextToken: string;
  readonly sortBy: string;
  readonly order: string;
}

interface ListRepositoriesOutput {
  readonly repositories: [];
  readonly nextToken: string;
}

interface ListTagsForResourceInput {
  readonly resourceArn: string;
  readonly nextToken: string;
}

interface ListTagsForResourceOutput {
  readonly tags: {[key: string]: any};
  readonly nextToken: string;
}

interface Location {
  readonly filePath: string;
  readonly filePosition: number;
  readonly relativeFileVersion: string;
}

interface ManualMergeRequiredException {
}

interface MaximumBranchesExceededException {
}

interface MaximumConflictResolutionEntriesExceededException {
}

interface MaximumFileContentToLoadExceededException {
}

interface MaximumFileEntriesExceededException {
}

interface MaximumItemsToCompareExceededException {
}

interface MaximumNumberOfApprovalsExceededException {
}

interface MaximumOpenPullRequestsExceededException {
}

interface MaximumRepositoryNamesExceededException {
}

interface MaximumRepositoryTriggersExceededException {
}

interface MaximumRuleTemplatesAssociatedWithRepositoryException {
}

interface MergeBranchesByFastForwardInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
}

interface MergeBranchesByFastForwardOutput {
  readonly commitId: string;
  readonly treeId: string;
}

interface MergeBranchesBySquashInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}

interface MergeBranchesBySquashOutput {
  readonly commitId: string;
  readonly treeId: string;
}

interface MergeBranchesByThreeWayInput {
  readonly repositoryName: string;
  readonly sourceCommitSpecifier: string;
  readonly destinationCommitSpecifier: string;
  readonly targetBranch: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly authorName: string;
  readonly email: string;
  readonly commitMessage: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}

interface MergeBranchesByThreeWayOutput {
  readonly commitId: string;
  readonly treeId: string;
}

interface MergeHunk {
  readonly isConflict: boolean;
  readonly source: MergeHunkDetail;
  readonly destination: MergeHunkDetail;
  readonly base: MergeHunkDetail;
}

interface MergeHunkDetail {
  readonly startLine: number;
  readonly endLine: number;
  readonly hunkContent: string;
}

interface MergeMetadata {
  readonly isMerged: boolean;
  readonly mergedBy: string;
  readonly mergeCommitId: string;
  readonly mergeOption: string;
}

interface MergeOperations {
  readonly source: string;
  readonly destination: string;
}

interface MergeOptionRequiredException {
}

interface MergePullRequestByFastForwardInput {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
}

interface MergePullRequestByFastForwardOutput {
  readonly pullRequest: PullRequest;
}

interface MergePullRequestBySquashInput {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly commitMessage: string;
  readonly authorName: string;
  readonly email: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}

interface MergePullRequestBySquashOutput {
  readonly pullRequest: PullRequest;
}

interface MergePullRequestByThreeWayInput {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly sourceCommitId: string;
  readonly conflictDetailLevel: string;
  readonly conflictResolutionStrategy: string;
  readonly commitMessage: string;
  readonly authorName: string;
  readonly email: string;
  readonly keepEmptyFolders: boolean;
  readonly conflictResolution: ConflictResolution;
}

interface MergePullRequestByThreeWayOutput {
  readonly pullRequest: PullRequest;
}

interface MultipleConflictResolutionEntriesException {
}

interface MultipleRepositoriesInPullRequestException {
}

interface NameLengthExceededException {
}

interface NoChangeException {
}

interface NumberOfRuleTemplatesExceededException {
}

interface NumberOfRulesExceededException {
}

interface ObjectTypes {
  readonly source: string;
  readonly destination: string;
  readonly base: string;
}

interface OriginApprovalRuleTemplate {
  readonly approvalRuleTemplateId: string;
  readonly approvalRuleTemplateName: string;
}

interface OverrideAlreadySetException {
}

interface OverridePullRequestApprovalRulesInput {
  readonly pullRequestId: string;
  readonly revisionId: string;
  readonly overrideStatus: string;
}

interface OverrideStatusRequiredException {
}

interface ParentCommitDoesNotExistException {
}

interface ParentCommitIdOutdatedException {
}

interface ParentCommitIdRequiredException {
}

interface PathDoesNotExistException {
}

interface PathRequiredException {
}

interface PostCommentForComparedCommitInput {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly location: Location;
  readonly content: string;
  readonly clientRequestToken: string;
}

interface PostCommentForComparedCommitOutput {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly beforeBlobId: string;
  readonly afterBlobId: string;
  readonly location: Location;
  readonly comment: Comment;
}

interface PostCommentForPullRequestInput {
  readonly pullRequestId: string;
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly location: Location;
  readonly content: string;
  readonly clientRequestToken: string;
}

interface PostCommentForPullRequestOutput {
  readonly repositoryName: string;
  readonly pullRequestId: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly beforeBlobId: string;
  readonly afterBlobId: string;
  readonly location: Location;
  readonly comment: Comment;
}

interface PostCommentReplyInput {
  readonly inReplyTo: string;
  readonly clientRequestToken: string;
  readonly content: string;
}

interface PostCommentReplyOutput {
  readonly comment: Comment;
}

interface PullRequest {
  readonly pullRequestId: string;
  readonly title: string;
  readonly description: string;
  readonly lastActivityDate: Date;
  readonly creationDate: Date;
  readonly pullRequestStatus: string;
  readonly authorArn: string;
  readonly pullRequestTargets: [];
  readonly clientRequestToken: string;
  readonly revisionId: string;
  readonly approvalRules: [];
}

interface PullRequestAlreadyClosedException {
}

interface PullRequestApprovalRulesNotSatisfiedException {
}

interface PullRequestCannotBeApprovedByAuthorException {
}

interface PullRequestCreatedEventMetadata {
  readonly repositoryName: string;
  readonly sourceCommitId: string;
  readonly destinationCommitId: string;
  readonly mergeBase: string;
}

interface PullRequestDoesNotExistException {
}

interface PullRequestEvent {
  readonly pullRequestId: string;
  readonly eventDate: Date;
  readonly pullRequestEventType: string;
  readonly actorArn: string;
  readonly pullRequestCreatedEventMetadata: PullRequestCreatedEventMetadata;
  readonly pullRequestStatusChangedEventMetadata: PullRequestStatusChangedEventMetadata;
  readonly pullRequestSourceReferenceUpdatedEventMetadata: PullRequestSourceReferenceUpdatedEventMetadata;
  readonly pullRequestMergedStateChangedEventMetadata: PullRequestMergedStateChangedEventMetadata;
  readonly approvalRuleEventMetadata: ApprovalRuleEventMetadata;
  readonly approvalStateChangedEventMetadata: ApprovalStateChangedEventMetadata;
  readonly approvalRuleOverriddenEventMetadata: ApprovalRuleOverriddenEventMetadata;
}

interface PullRequestIdRequiredException {
}

interface PullRequestMergedStateChangedEventMetadata {
  readonly repositoryName: string;
  readonly destinationReference: string;
  readonly mergeMetadata: MergeMetadata;
}

interface PullRequestSourceReferenceUpdatedEventMetadata {
  readonly repositoryName: string;
  readonly beforeCommitId: string;
  readonly afterCommitId: string;
  readonly mergeBase: string;
}

interface PullRequestStatusChangedEventMetadata {
  readonly pullRequestStatus: string;
}

interface PullRequestStatusRequiredException {
}

interface PullRequestTarget {
  readonly repositoryName: string;
  readonly sourceReference: string;
  readonly destinationReference: string;
  readonly destinationCommit: string;
  readonly sourceCommit: string;
  readonly mergeBase: string;
  readonly mergeMetadata: MergeMetadata;
}

interface PutCommentReactionInput {
  readonly commentId: string;
  readonly reactionValue: string;
}

interface PutFileEntry {
  readonly filePath: string;
  readonly fileMode: string;
  readonly fileContent: unknown;
  readonly sourceFile: SourceFileSpecifier;
}

interface PutFileEntryConflictException {
}

interface PutFileInput {
  readonly repositoryName: string;
  readonly branchName: string;
  readonly fileContent: unknown;
  readonly filePath: string;
  readonly fileMode: string;
  readonly parentCommitId: string;
  readonly commitMessage: string;
  readonly name: string;
  readonly email: string;
}

interface PutFileOutput {
  readonly commitId: string;
  readonly blobId: string;
  readonly treeId: string;
}

interface PutRepositoryTriggersInput {
  readonly repositoryName: string;
  readonly triggers: [];
}

interface PutRepositoryTriggersOutput {
  readonly configurationId: string;
}

interface ReactionForComment {
  readonly reaction: ReactionValueFormats;
  readonly reactionUsers: [];
  readonly reactionsFromDeletedUsersCount: number;
}

interface ReactionLimitExceededException {
}

interface ReactionValueFormats {
  readonly emoji: string;
  readonly shortCode: string;
  readonly unicode: string;
}

interface ReactionValueRequiredException {
}

interface ReferenceDoesNotExistException {
}

interface ReferenceNameRequiredException {
}

interface ReferenceTypeNotSupportedException {
}

interface ReplaceContentEntry {
  readonly filePath: string;
  readonly replacementType: string;
  readonly content: unknown;
  readonly fileMode: string;
}

interface ReplacementContentRequiredException {
}

interface ReplacementTypeRequiredException {
}

interface RepositoryDoesNotExistException {
}

interface RepositoryLimitExceededException {
}

interface RepositoryMetadata {
  readonly accountId: string;
  readonly repositoryId: string;
  readonly repositoryName: string;
  readonly repositoryDescription: string;
  readonly defaultBranch: string;
  readonly lastModifiedDate: Date;
  readonly creationDate: Date;
  readonly cloneUrlHttp: string;
  readonly cloneUrlSsh: string;
  readonly Arn: string;
}

interface RepositoryNameExistsException {
}

interface RepositoryNameIdPair {
  readonly repositoryName: string;
  readonly repositoryId: string;
}

interface RepositoryNameRequiredException {
}

interface RepositoryNamesRequiredException {
}

interface RepositoryNotAssociatedWithPullRequestException {
}

interface RepositoryTrigger {
  readonly name: string;
  readonly destinationArn: string;
  readonly customData: string;
  readonly branches: [];
  readonly events: [];
}

interface RepositoryTriggerBranchNameListRequiredException {
}

interface RepositoryTriggerDestinationArnRequiredException {
}

interface RepositoryTriggerEventsListRequiredException {
}

interface RepositoryTriggerExecutionFailure {
  readonly trigger: string;
  readonly failureMessage: string;
}

interface RepositoryTriggerNameRequiredException {
}

interface RepositoryTriggersListRequiredException {
}

interface ResourceArnRequiredException {
}

interface RestrictedSourceFileException {
}

interface RevisionIdRequiredException {
}

interface RevisionNotCurrentException {
}

interface SameFileContentException {
}

interface SamePathRequestException {
}

interface SetFileModeEntry {
  readonly filePath: string;
  readonly fileMode: string;
}

interface SourceAndDestinationAreSameException {
}

interface SourceFileOrContentRequiredException {
}

interface SourceFileSpecifier {
  readonly filePath: string;
  readonly isMove: boolean;
}

interface SubModule {
  readonly commitId: string;
  readonly absolutePath: string;
  readonly relativePath: string;
}

interface SymbolicLink {
  readonly blobId: string;
  readonly absolutePath: string;
  readonly relativePath: string;
  readonly fileMode: string;
}

interface TagKeysListRequiredException {
}

interface TagPolicyException {
}

interface TagResourceInput {
  readonly resourceArn: string;
  readonly tags: {[key: string]: any};
}

interface TagsMapRequiredException {
}

interface Target {
  readonly repositoryName: string;
  readonly sourceReference: string;
  readonly destinationReference: string;
}

interface TargetRequiredException {
}

interface TargetsRequiredException {
}

interface TestRepositoryTriggersInput {
  readonly repositoryName: string;
  readonly triggers: [];
}

interface TestRepositoryTriggersOutput {
  readonly successfulExecutions: [];
  readonly failedExecutions: [];
}

interface TipOfSourceReferenceIsDifferentException {
}

interface TipsDivergenceExceededException {
}

interface TitleRequiredException {
}

interface TooManyTagsException {
}

interface UntagResourceInput {
  readonly resourceArn: string;
  readonly tagKeys: [];
}

interface UpdateApprovalRuleTemplateContentInput {
  readonly approvalRuleTemplateName: string;
  readonly newRuleContent: string;
  readonly existingRuleContentSha256: string;
}

interface UpdateApprovalRuleTemplateContentOutput {
  readonly approvalRuleTemplate: ApprovalRuleTemplate;
}

interface UpdateApprovalRuleTemplateDescriptionInput {
  readonly approvalRuleTemplateName: string;
  readonly approvalRuleTemplateDescription: string;
}

interface UpdateApprovalRuleTemplateDescriptionOutput {
  readonly approvalRuleTemplate: ApprovalRuleTemplate;
}

interface UpdateApprovalRuleTemplateNameInput {
  readonly oldApprovalRuleTemplateName: string;
  readonly newApprovalRuleTemplateName: string;
}

interface UpdateApprovalRuleTemplateNameOutput {
  readonly approvalRuleTemplate: ApprovalRuleTemplate;
}

interface UpdateCommentInput {
  readonly commentId: string;
  readonly content: string;
}

interface UpdateCommentOutput {
  readonly comment: Comment;
}

interface UpdateDefaultBranchInput {
  readonly repositoryName: string;
  readonly defaultBranchName: string;
}

interface UpdatePullRequestApprovalRuleContentInput {
  readonly pullRequestId: string;
  readonly approvalRuleName: string;
  readonly existingRuleContentSha256: string;
  readonly newRuleContent: string;
}

interface UpdatePullRequestApprovalRuleContentOutput {
  readonly approvalRule: ApprovalRule;
}

interface UpdatePullRequestApprovalStateInput {
  readonly pullRequestId: string;
  readonly revisionId: string;
  readonly approvalState: string;
}

interface UpdatePullRequestDescriptionInput {
  readonly pullRequestId: string;
  readonly description: string;
}

interface UpdatePullRequestDescriptionOutput {
  readonly pullRequest: PullRequest;
}

interface UpdatePullRequestStatusInput {
  readonly pullRequestId: string;
  readonly pullRequestStatus: string;
}

interface UpdatePullRequestStatusOutput {
  readonly pullRequest: PullRequest;
}

interface UpdatePullRequestTitleInput {
  readonly pullRequestId: string;
  readonly title: string;
}

interface UpdatePullRequestTitleOutput {
  readonly pullRequest: PullRequest;
}

interface UpdateRepositoryDescriptionInput {
  readonly repositoryName: string;
  readonly repositoryDescription: string;
}

interface UpdateRepositoryNameInput {
  readonly oldName: string;
  readonly newName: string;
}

interface UserInfo {
  readonly name: string;
  readonly email: string;
  readonly date: string;
}

